// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sandglass.proto

/*
	Package sgproto is a generated protocol buffer package.

	It is generated from these files:
		sandglass.proto

	It has these top-level messages:
		Message
		ProduceMessageRequest
		ProduceResponse
		TopicConfig
		GetTopicParams
		GetTopicReply
		TopicReply
		StoreLocallyReply
		FetchFromRequest
		FetchRangeRequest
		GetRequest
		ConsumeFromGroupRequest
		MarkRequest
		MarkResponse
		GetMarkRequest
		LastOffsetReply
		LastOffsetRequest
		FetchFromSyncRequest
		HasResponse
		MarkState
		EndOfLogRequest
		EndOfLogReply
		MergeState
		MergeOperation
*/
package sgproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "github.com/golang/protobuf/ptypes/duration"
import _ "github.com/gogo/protobuf/gogoproto"

import time "time"

import bytes "bytes"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TopicKind int32

const (
	TopicKind_TimerKind TopicKind = 0
	TopicKind_KVKind    TopicKind = 1
)

var TopicKind_name = map[int32]string{
	0: "TimerKind",
	1: "KVKind",
}
var TopicKind_value = map[string]int32{
	"TimerKind": 0,
	"KVKind":    1,
}

func (x TopicKind) String() string {
	return proto.EnumName(TopicKind_name, int32(x))
}
func (TopicKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{0} }

type StorageDriver int32

const (
	StorageDriver_RocksDB StorageDriver = 0
	StorageDriver_Badger  StorageDriver = 1
)

var StorageDriver_name = map[int32]string{
	0: "RocksDB",
	1: "Badger",
}
var StorageDriver_value = map[string]int32{
	"RocksDB": 0,
	"Badger":  1,
}

func (x StorageDriver) String() string {
	return proto.EnumName(StorageDriver_name, int32(x))
}
func (StorageDriver) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{1} }

type MarkKind int32

const (
	MarkKind_Unknown         MarkKind = 0
	MarkKind_Consumed        MarkKind = 10
	MarkKind_NotAcknowledged MarkKind = 20
	MarkKind_Acknowledged    MarkKind = 30
	MarkKind_Commited        MarkKind = 40
)

var MarkKind_name = map[int32]string{
	0:  "Unknown",
	10: "Consumed",
	20: "NotAcknowledged",
	30: "Acknowledged",
	40: "Commited",
}
var MarkKind_value = map[string]int32{
	"Unknown":         0,
	"Consumed":        10,
	"NotAcknowledged": 20,
	"Acknowledged":    30,
	"Commited":        40,
}

func (x MarkKind) String() string {
	return proto.EnumName(MarkKind_name, int32(x))
}
func (MarkKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{2} }

type MergeOperation_Operation int32

const (
	MergeOperation_APPEND MergeOperation_Operation = 0
	MergeOperation_CUT    MergeOperation_Operation = 1
)

var MergeOperation_Operation_name = map[int32]string{
	0: "APPEND",
	1: "CUT",
}
var MergeOperation_Operation_value = map[string]int32{
	"APPEND": 0,
	"CUT":    1,
}

func (x MergeOperation_Operation) String() string {
	return proto.EnumName(MergeOperation_Operation_name, int32(x))
}
func (MergeOperation_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{23, 0}
}

type Message struct {
	Index         uint64        `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	Offset        Offset        `protobuf:"bytes,11,opt,name=offset,proto3,customtype=Offset" json:"offset"`
	ProducedAt    time.Time     `protobuf:"bytes,12,opt,name=producedAt,stdtime" json:"producedAt"`
	ConsumeIn     time.Duration `protobuf:"bytes,13,opt,name=consumeIn,stdduration" json:"consumeIn"`
	Key           []byte        `protobuf:"bytes,20,opt,name=key,proto3" json:"key,omitempty"`
	ClusteringKey []byte        `protobuf:"bytes,21,opt,name=clusteringKey,proto3" json:"clusteringKey,omitempty"`
	Value         []byte        `protobuf:"bytes,30,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{0} }

func (m *Message) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Message) GetProducedAt() time.Time {
	if m != nil {
		return m.ProducedAt
	}
	return time.Time{}
}

func (m *Message) GetConsumeIn() time.Duration {
	if m != nil {
		return m.ConsumeIn
	}
	return 0
}

func (m *Message) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Message) GetClusteringKey() []byte {
	if m != nil {
		return m.ClusteringKey
	}
	return nil
}

func (m *Message) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type ProduceMessageRequest struct {
	Topic     string     `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string     `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Messages  []*Message `protobuf:"bytes,3,rep,name=messages" json:"messages,omitempty"`
}

func (m *ProduceMessageRequest) Reset()                    { *m = ProduceMessageRequest{} }
func (*ProduceMessageRequest) ProtoMessage()               {}
func (*ProduceMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{1} }

func (m *ProduceMessageRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ProduceMessageRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *ProduceMessageRequest) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type ProduceResponse struct {
	Offsets []Offset `protobuf:"bytes,1,rep,name=offsets,customtype=Offset" json:"offsets"`
}

func (m *ProduceResponse) Reset()                    { *m = ProduceResponse{} }
func (*ProduceResponse) ProtoMessage()               {}
func (*ProduceResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{2} }

type TopicConfig struct {
	Name              string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind              TopicKind     `protobuf:"varint,2,opt,name=kind,proto3,enum=sandglass.TopicKind" json:"kind,omitempty"`
	ReplicationFactor int32         `protobuf:"varint,3,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	NumPartitions     int32         `protobuf:"varint,4,opt,name=numPartitions,proto3" json:"numPartitions,omitempty"`
	StorageDriver     StorageDriver `protobuf:"varint,5,opt,name=storageDriver,proto3,enum=sandglass.StorageDriver" json:"storageDriver,omitempty"`
}

func (m *TopicConfig) Reset()                    { *m = TopicConfig{} }
func (*TopicConfig) ProtoMessage()               {}
func (*TopicConfig) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{3} }

func (m *TopicConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TopicConfig) GetKind() TopicKind {
	if m != nil {
		return m.Kind
	}
	return TopicKind_TimerKind
}

func (m *TopicConfig) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *TopicConfig) GetNumPartitions() int32 {
	if m != nil {
		return m.NumPartitions
	}
	return 0
}

func (m *TopicConfig) GetStorageDriver() StorageDriver {
	if m != nil {
		return m.StorageDriver
	}
	return StorageDriver_RocksDB
}

type GetTopicParams struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetTopicParams) Reset()                    { *m = GetTopicParams{} }
func (*GetTopicParams) ProtoMessage()               {}
func (*GetTopicParams) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{4} }

func (m *GetTopicParams) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetTopicReply struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Partitions []string `protobuf:"bytes,2,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *GetTopicReply) Reset()                    { *m = GetTopicReply{} }
func (*GetTopicReply) ProtoMessage()               {}
func (*GetTopicReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{5} }

func (m *GetTopicReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetTopicReply) GetPartitions() []string {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type TopicReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *TopicReply) Reset()                    { *m = TopicReply{} }
func (*TopicReply) ProtoMessage()               {}
func (*TopicReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{6} }

func (m *TopicReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type StoreLocallyReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *StoreLocallyReply) Reset()                    { *m = StoreLocallyReply{} }
func (*StoreLocallyReply) ProtoMessage()               {}
func (*StoreLocallyReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{7} }

func (m *StoreLocallyReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type FetchFromRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      Offset `protobuf:"bytes,3,opt,name=from,proto3,customtype=Offset" json:"from"`
}

func (m *FetchFromRequest) Reset()                    { *m = FetchFromRequest{} }
func (*FetchFromRequest) ProtoMessage()               {}
func (*FetchFromRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{8} }

func (m *FetchFromRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchFromRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type FetchRangeRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      Offset `protobuf:"bytes,3,opt,name=from,proto3,customtype=Offset" json:"from"`
	To        Offset `protobuf:"bytes,4,opt,name=to,proto3,customtype=Offset" json:"to"`
}

func (m *FetchRangeRequest) Reset()                    { *m = FetchRangeRequest{} }
func (*FetchRangeRequest) ProtoMessage()               {}
func (*FetchRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{9} }

func (m *FetchRangeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchRangeRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type GetRequest struct {
	Topic         string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Key           []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	ClusteringKey []byte `protobuf:"bytes,4,opt,name=clusteringKey,proto3" json:"clusteringKey,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{10} }

func (m *GetRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *GetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GetRequest) GetClusteringKey() []byte {
	if m != nil {
		return m.ClusteringKey
	}
	return nil
}

type ConsumeFromGroupRequest struct {
	Topic             string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition         string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroupName string `protobuf:"bytes,3,opt,name=consumerGroupName,proto3" json:"consumerGroupName,omitempty"`
	ConsumerName      string `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
}

func (m *ConsumeFromGroupRequest) Reset()      { *m = ConsumeFromGroupRequest{} }
func (*ConsumeFromGroupRequest) ProtoMessage() {}
func (*ConsumeFromGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{11}
}

func (m *ConsumeFromGroupRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetConsumerGroupName() string {
	if m != nil {
		return m.ConsumerGroupName
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type MarkRequest struct {
	Topic         string     `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string     `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string     `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string     `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Offsets       []Offset   `protobuf:"bytes,5,rep,name=offsets,customtype=Offset" json:"offsets"`
	State         *MarkState `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
}

func (m *MarkRequest) Reset()                    { *m = MarkRequest{} }
func (*MarkRequest) ProtoMessage()               {}
func (*MarkRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{12} }

func (m *MarkRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *MarkRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *MarkRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *MarkRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

func (m *MarkRequest) GetState() *MarkState {
	if m != nil {
		return m.State
	}
	return nil
}

type MarkResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *MarkResponse) Reset()                    { *m = MarkResponse{} }
func (*MarkResponse) ProtoMessage()               {}
func (*MarkResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{13} }

func (m *MarkResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type GetMarkRequest struct {
	Topic         string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Offset        Offset `protobuf:"bytes,5,opt,name=offset,proto3,customtype=Offset" json:"offset"`
}

func (m *GetMarkRequest) Reset()                    { *m = GetMarkRequest{} }
func (*GetMarkRequest) ProtoMessage()               {}
func (*GetMarkRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{14} }

func (m *GetMarkRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetMarkRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *GetMarkRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *GetMarkRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type LastOffsetReply struct {
	Offset Offset `protobuf:"bytes,1,opt,name=offset,proto3,customtype=Offset" json:"offset"`
}

func (m *LastOffsetReply) Reset()                    { *m = LastOffsetReply{} }
func (*LastOffsetReply) ProtoMessage()               {}
func (*LastOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{15} }

type LastOffsetRequest struct {
	Topic         string   `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string   `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string   `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string   `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Kind          MarkKind `protobuf:"varint,5,opt,name=kind,proto3,enum=sandglass.MarkKind" json:"kind,omitempty"`
}

func (m *LastOffsetRequest) Reset()                    { *m = LastOffsetRequest{} }
func (*LastOffsetRequest) ProtoMessage()               {}
func (*LastOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{16} }

func (m *LastOffsetRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *LastOffsetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *LastOffsetRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *LastOffsetRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

func (m *LastOffsetRequest) GetKind() MarkKind {
	if m != nil {
		return m.Kind
	}
	return MarkKind_Unknown
}

type FetchFromSyncRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      []byte `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *FetchFromSyncRequest) Reset()                    { *m = FetchFromSyncRequest{} }
func (*FetchFromSyncRequest) ProtoMessage()               {}
func (*FetchFromSyncRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{17} }

func (m *FetchFromSyncRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchFromSyncRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *FetchFromSyncRequest) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

type HasResponse struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
}

func (m *HasResponse) Reset()                    { *m = HasResponse{} }
func (*HasResponse) ProtoMessage()               {}
func (*HasResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{18} }

func (m *HasResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type MarkState struct {
	Kind          MarkKind `protobuf:"varint,1,opt,name=kind,proto3,enum=sandglass.MarkKind" json:"kind,omitempty"`
	DeliveryCount int32    `protobuf:"varint,2,opt,name=deliveryCount,proto3" json:"deliveryCount,omitempty"`
}

func (m *MarkState) Reset()                    { *m = MarkState{} }
func (*MarkState) ProtoMessage()               {}
func (*MarkState) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{19} }

func (m *MarkState) GetKind() MarkKind {
	if m != nil {
		return m.Kind
	}
	return MarkKind_Unknown
}

func (m *MarkState) GetDeliveryCount() int32 {
	if m != nil {
		return m.DeliveryCount
	}
	return 0
}

type EndOfLogRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
}

func (m *EndOfLogRequest) Reset()                    { *m = EndOfLogRequest{} }
func (*EndOfLogRequest) ProtoMessage()               {}
func (*EndOfLogRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{20} }

func (m *EndOfLogRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *EndOfLogRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type EndOfLogReply struct {
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *EndOfLogReply) Reset()                    { *m = EndOfLogReply{} }
func (*EndOfLogReply) ProtoMessage()               {}
func (*EndOfLogReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{21} }

func (m *EndOfLogReply) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type MergeState struct {
	Messages []*Message `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
}

func (m *MergeState) Reset()                    { *m = MergeState{} }
func (*MergeState) ProtoMessage()               {}
func (*MergeState) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{22} }

func (m *MergeState) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type MergeOperation struct {
	Operation MergeOperation_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=sandglass.MergeOperation_Operation" json:"operation,omitempty"`
	// APPEND
	Messages []*Message `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	// CUT
	N int32 `protobuf:"varint,3,opt,name=N,proto3" json:"N,omitempty"`
}

func (m *MergeOperation) Reset()                    { *m = MergeOperation{} }
func (*MergeOperation) ProtoMessage()               {}
func (*MergeOperation) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{23} }

func (m *MergeOperation) GetOperation() MergeOperation_Operation {
	if m != nil {
		return m.Operation
	}
	return MergeOperation_APPEND
}

func (m *MergeOperation) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *MergeOperation) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func init() {
	proto.RegisterType((*Message)(nil), "sandglass.Message")
	proto.RegisterType((*ProduceMessageRequest)(nil), "sandglass.ProduceMessageRequest")
	proto.RegisterType((*ProduceResponse)(nil), "sandglass.ProduceResponse")
	proto.RegisterType((*TopicConfig)(nil), "sandglass.TopicConfig")
	proto.RegisterType((*GetTopicParams)(nil), "sandglass.GetTopicParams")
	proto.RegisterType((*GetTopicReply)(nil), "sandglass.GetTopicReply")
	proto.RegisterType((*TopicReply)(nil), "sandglass.TopicReply")
	proto.RegisterType((*StoreLocallyReply)(nil), "sandglass.StoreLocallyReply")
	proto.RegisterType((*FetchFromRequest)(nil), "sandglass.FetchFromRequest")
	proto.RegisterType((*FetchRangeRequest)(nil), "sandglass.FetchRangeRequest")
	proto.RegisterType((*GetRequest)(nil), "sandglass.GetRequest")
	proto.RegisterType((*ConsumeFromGroupRequest)(nil), "sandglass.ConsumeFromGroupRequest")
	proto.RegisterType((*MarkRequest)(nil), "sandglass.MarkRequest")
	proto.RegisterType((*MarkResponse)(nil), "sandglass.MarkResponse")
	proto.RegisterType((*GetMarkRequest)(nil), "sandglass.GetMarkRequest")
	proto.RegisterType((*LastOffsetReply)(nil), "sandglass.LastOffsetReply")
	proto.RegisterType((*LastOffsetRequest)(nil), "sandglass.LastOffsetRequest")
	proto.RegisterType((*FetchFromSyncRequest)(nil), "sandglass.FetchFromSyncRequest")
	proto.RegisterType((*HasResponse)(nil), "sandglass.HasResponse")
	proto.RegisterType((*MarkState)(nil), "sandglass.MarkState")
	proto.RegisterType((*EndOfLogRequest)(nil), "sandglass.EndOfLogRequest")
	proto.RegisterType((*EndOfLogReply)(nil), "sandglass.EndOfLogReply")
	proto.RegisterType((*MergeState)(nil), "sandglass.MergeState")
	proto.RegisterType((*MergeOperation)(nil), "sandglass.MergeOperation")
	proto.RegisterEnum("sandglass.TopicKind", TopicKind_name, TopicKind_value)
	proto.RegisterEnum("sandglass.StorageDriver", StorageDriver_name, StorageDriver_value)
	proto.RegisterEnum("sandglass.MarkKind", MarkKind_name, MarkKind_value)
	proto.RegisterEnum("sandglass.MergeOperation_Operation", MergeOperation_Operation_name, MergeOperation_Operation_value)
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	if !this.ProducedAt.Equal(that1.ProducedAt) {
		return false
	}
	if this.ConsumeIn != that1.ConsumeIn {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.ClusteringKey, that1.ClusteringKey) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	return true
}
func (this *ProduceMessageRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProduceMessageRequest)
	if !ok {
		that2, ok := that.(ProduceMessageRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	return true
}
func (this *ProduceResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProduceResponse)
	if !ok {
		that2, ok := that.(ProduceResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Offsets) != len(that1.Offsets) {
		return false
	}
	for i := range this.Offsets {
		if !this.Offsets[i].Equal(that1.Offsets[i]) {
			return false
		}
	}
	return true
}
func (this *TopicConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TopicConfig)
	if !ok {
		that2, ok := that.(TopicConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if this.NumPartitions != that1.NumPartitions {
		return false
	}
	if this.StorageDriver != that1.StorageDriver {
		return false
	}
	return true
}
func (this *GetTopicParams) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetTopicParams)
	if !ok {
		that2, ok := that.(GetTopicParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GetTopicReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetTopicReply)
	if !ok {
		that2, ok := that.(GetTopicReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if this.Partitions[i] != that1.Partitions[i] {
			return false
		}
	}
	return true
}
func (this *TopicReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TopicReply)
	if !ok {
		that2, ok := that.(TopicReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *StoreLocallyReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StoreLocallyReply)
	if !ok {
		that2, ok := that.(StoreLocallyReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *FetchFromRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchFromRequest)
	if !ok {
		that2, ok := that.(FetchFromRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	return true
}
func (this *FetchRangeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchRangeRequest)
	if !ok {
		that2, ok := that.(FetchRangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	return true
}
func (this *GetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetRequest)
	if !ok {
		that2, ok := that.(GetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.ClusteringKey, that1.ClusteringKey) {
		return false
	}
	return true
}
func (this *ConsumeFromGroupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ConsumeFromGroupRequest)
	if !ok {
		that2, ok := that.(ConsumeFromGroupRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroupName != that1.ConsumerGroupName {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	return true
}
func (this *MarkRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MarkRequest)
	if !ok {
		that2, ok := that.(MarkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if len(this.Offsets) != len(that1.Offsets) {
		return false
	}
	for i := range this.Offsets {
		if !this.Offsets[i].Equal(that1.Offsets[i]) {
			return false
		}
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	return true
}
func (this *MarkResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MarkResponse)
	if !ok {
		that2, ok := that.(MarkResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *GetMarkRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetMarkRequest)
	if !ok {
		that2, ok := that.(GetMarkRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	return true
}
func (this *LastOffsetReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LastOffsetReply)
	if !ok {
		that2, ok := that.(LastOffsetReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	return true
}
func (this *LastOffsetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LastOffsetRequest)
	if !ok {
		that2, ok := that.(LastOffsetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *FetchFromSyncRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchFromSyncRequest)
	if !ok {
		that2, ok := that.(FetchFromSyncRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.From, that1.From) {
		return false
	}
	return true
}
func (this *HasResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HasResponse)
	if !ok {
		that2, ok := that.(HasResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Exists != that1.Exists {
		return false
	}
	return true
}
func (this *MarkState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MarkState)
	if !ok {
		that2, ok := that.(MarkState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.DeliveryCount != that1.DeliveryCount {
		return false
	}
	return true
}
func (this *EndOfLogRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EndOfLogRequest)
	if !ok {
		that2, ok := that.(EndOfLogRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	return true
}
func (this *EndOfLogReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EndOfLogReply)
	if !ok {
		that2, ok := that.(EndOfLogReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	return true
}
func (this *MergeState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MergeState)
	if !ok {
		that2, ok := that.(MergeState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	return true
}
func (this *MergeOperation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MergeOperation)
	if !ok {
		that2, ok := that.(MergeOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Operation != that1.Operation {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if this.N != that1.N {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BrokerService service

type BrokerServiceClient interface {
	CreateTopic(ctx context.Context, in *TopicConfig, opts ...grpc.CallOption) (*TopicReply, error)
	GetTopic(ctx context.Context, in *GetTopicParams, opts ...grpc.CallOption) (*GetTopicReply, error)
	Produce(ctx context.Context, in *ProduceMessageRequest, opts ...grpc.CallOption) (*ProduceResponse, error)
	FetchFrom(ctx context.Context, in *FetchFromRequest, opts ...grpc.CallOption) (BrokerService_FetchFromClient, error)
	FetchRange(ctx context.Context, in *FetchRangeRequest, opts ...grpc.CallOption) (BrokerService_FetchRangeClient, error)
	ConsumeFromGroup(ctx context.Context, in *ConsumeFromGroupRequest, opts ...grpc.CallOption) (BrokerService_ConsumeFromGroupClient, error)
	Acknowledge(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*MarkResponse, error)
	NotAcknowledge(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*MarkResponse, error)
}

type brokerServiceClient struct {
	cc *grpc.ClientConn
}

func NewBrokerServiceClient(cc *grpc.ClientConn) BrokerServiceClient {
	return &brokerServiceClient{cc}
}

func (c *brokerServiceClient) CreateTopic(ctx context.Context, in *TopicConfig, opts ...grpc.CallOption) (*TopicReply, error) {
	out := new(TopicReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/CreateTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) GetTopic(ctx context.Context, in *GetTopicParams, opts ...grpc.CallOption) (*GetTopicReply, error) {
	out := new(GetTopicReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/GetTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Produce(ctx context.Context, in *ProduceMessageRequest, opts ...grpc.CallOption) (*ProduceResponse, error) {
	out := new(ProduceResponse)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Produce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) FetchFrom(ctx context.Context, in *FetchFromRequest, opts ...grpc.CallOption) (BrokerService_FetchFromClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[0], c.cc, "/sandglass.BrokerService/FetchFrom", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchFromClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchFromClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchFromClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) FetchRange(ctx context.Context, in *FetchRangeRequest, opts ...grpc.CallOption) (BrokerService_FetchRangeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[1], c.cc, "/sandglass.BrokerService/FetchRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchRangeClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchRangeClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchRangeClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) ConsumeFromGroup(ctx context.Context, in *ConsumeFromGroupRequest, opts ...grpc.CallOption) (BrokerService_ConsumeFromGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[2], c.cc, "/sandglass.BrokerService/ConsumeFromGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceConsumeFromGroupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_ConsumeFromGroupClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceConsumeFromGroupClient struct {
	grpc.ClientStream
}

func (x *brokerServiceConsumeFromGroupClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) Acknowledge(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*MarkResponse, error) {
	out := new(MarkResponse)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Acknowledge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) NotAcknowledge(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*MarkResponse, error) {
	out := new(MarkResponse)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/NotAcknowledge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BrokerService service

type BrokerServiceServer interface {
	CreateTopic(context.Context, *TopicConfig) (*TopicReply, error)
	GetTopic(context.Context, *GetTopicParams) (*GetTopicReply, error)
	Produce(context.Context, *ProduceMessageRequest) (*ProduceResponse, error)
	FetchFrom(*FetchFromRequest, BrokerService_FetchFromServer) error
	FetchRange(*FetchRangeRequest, BrokerService_FetchRangeServer) error
	ConsumeFromGroup(*ConsumeFromGroupRequest, BrokerService_ConsumeFromGroupServer) error
	Acknowledge(context.Context, *MarkRequest) (*MarkResponse, error)
	NotAcknowledge(context.Context, *MarkRequest) (*MarkResponse, error)
}

func RegisterBrokerServiceServer(s *grpc.Server, srv BrokerServiceServer) {
	s.RegisterService(&_BrokerService_serviceDesc, srv)
}

func _BrokerService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).CreateTopic(ctx, req.(*TopicConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_GetTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).GetTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/GetTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).GetTopic(ctx, req.(*GetTopicParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProduceMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Produce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Produce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Produce(ctx, req.(*ProduceMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_FetchFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchFromRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchFrom(m, &brokerServiceFetchFromServer{stream})
}

type BrokerService_FetchFromServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchFromServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchFromServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_FetchRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchRange(m, &brokerServiceFetchRangeServer{stream})
}

type BrokerService_FetchRangeServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchRangeServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchRangeServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_ConsumeFromGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsumeFromGroupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).ConsumeFromGroup(m, &brokerServiceConsumeFromGroupServer{stream})
}

type BrokerService_ConsumeFromGroupServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceConsumeFromGroupServer struct {
	grpc.ServerStream
}

func (x *brokerServiceConsumeFromGroupServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_Acknowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Acknowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Acknowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Acknowledge(ctx, req.(*MarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_NotAcknowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).NotAcknowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/NotAcknowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).NotAcknowledge(ctx, req.(*MarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BrokerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sandglass.BrokerService",
	HandlerType: (*BrokerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTopic",
			Handler:    _BrokerService_CreateTopic_Handler,
		},
		{
			MethodName: "GetTopic",
			Handler:    _BrokerService_GetTopic_Handler,
		},
		{
			MethodName: "Produce",
			Handler:    _BrokerService_Produce_Handler,
		},
		{
			MethodName: "Acknowledge",
			Handler:    _BrokerService_Acknowledge_Handler,
		},
		{
			MethodName: "NotAcknowledge",
			Handler:    _BrokerService_NotAcknowledge_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchFrom",
			Handler:       _BrokerService_FetchFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchRange",
			Handler:       _BrokerService_FetchRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ConsumeFromGroup",
			Handler:       _BrokerService_ConsumeFromGroup_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sandglass.proto",
}

// Client API for InternalService service

type InternalServiceClient interface {
	GetByKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Message, error)
	HasKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*HasResponse, error)
	FetchFromSync(ctx context.Context, in *FetchFromSyncRequest, opts ...grpc.CallOption) (InternalService_FetchFromSyncClient, error)
	LastOffset(ctx context.Context, in *LastOffsetRequest, opts ...grpc.CallOption) (*LastOffsetReply, error)
	Mark(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*MarkResponse, error)
	GetMarkStateMessage(ctx context.Context, in *GetMarkRequest, opts ...grpc.CallOption) (*Message, error)
	EndOfLog(ctx context.Context, in *EndOfLogRequest, opts ...grpc.CallOption) (*EndOfLogReply, error)
}

type internalServiceClient struct {
	cc *grpc.ClientConn
}

func NewInternalServiceClient(cc *grpc.ClientConn) InternalServiceClient {
	return &internalServiceClient{cc}
}

func (c *internalServiceClient) GetByKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/GetByKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) HasKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*HasResponse, error) {
	out := new(HasResponse)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/HasKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) FetchFromSync(ctx context.Context, in *FetchFromSyncRequest, opts ...grpc.CallOption) (InternalService_FetchFromSyncClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InternalService_serviceDesc.Streams[0], c.cc, "/sandglass.InternalService/FetchFromSync", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalServiceFetchFromSyncClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InternalService_FetchFromSyncClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type internalServiceFetchFromSyncClient struct {
	grpc.ClientStream
}

func (x *internalServiceFetchFromSyncClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalServiceClient) LastOffset(ctx context.Context, in *LastOffsetRequest, opts ...grpc.CallOption) (*LastOffsetReply, error) {
	out := new(LastOffsetReply)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/LastOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) Mark(ctx context.Context, in *MarkRequest, opts ...grpc.CallOption) (*MarkResponse, error) {
	out := new(MarkResponse)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/Mark", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) GetMarkStateMessage(ctx context.Context, in *GetMarkRequest, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/GetMarkStateMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) EndOfLog(ctx context.Context, in *EndOfLogRequest, opts ...grpc.CallOption) (*EndOfLogReply, error) {
	out := new(EndOfLogReply)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/EndOfLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for InternalService service

type InternalServiceServer interface {
	GetByKey(context.Context, *GetRequest) (*Message, error)
	HasKey(context.Context, *GetRequest) (*HasResponse, error)
	FetchFromSync(*FetchFromSyncRequest, InternalService_FetchFromSyncServer) error
	LastOffset(context.Context, *LastOffsetRequest) (*LastOffsetReply, error)
	Mark(context.Context, *MarkRequest) (*MarkResponse, error)
	GetMarkStateMessage(context.Context, *GetMarkRequest) (*Message, error)
	EndOfLog(context.Context, *EndOfLogRequest) (*EndOfLogReply, error)
}

func RegisterInternalServiceServer(s *grpc.Server, srv InternalServiceServer) {
	s.RegisterService(&_InternalService_serviceDesc, srv)
}

func _InternalService_GetByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/GetByKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetByKey(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_HasKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).HasKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/HasKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).HasKey(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_FetchFromSync_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchFromSyncRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServiceServer).FetchFromSync(m, &internalServiceFetchFromSyncServer{stream})
}

type InternalService_FetchFromSyncServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type internalServiceFetchFromSyncServer struct {
	grpc.ServerStream
}

func (x *internalServiceFetchFromSyncServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _InternalService_LastOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).LastOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/LastOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).LastOffset(ctx, req.(*LastOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_Mark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).Mark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/Mark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).Mark(ctx, req.(*MarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_GetMarkStateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetMarkStateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/GetMarkStateMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetMarkStateMessage(ctx, req.(*GetMarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_EndOfLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndOfLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).EndOfLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/EndOfLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).EndOfLog(ctx, req.(*EndOfLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InternalService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sandglass.InternalService",
	HandlerType: (*InternalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetByKey",
			Handler:    _InternalService_GetByKey_Handler,
		},
		{
			MethodName: "HasKey",
			Handler:    _InternalService_HasKey_Handler,
		},
		{
			MethodName: "LastOffset",
			Handler:    _InternalService_LastOffset_Handler,
		},
		{
			MethodName: "Mark",
			Handler:    _InternalService_Mark_Handler,
		},
		{
			MethodName: "GetMarkStateMessage",
			Handler:    _InternalService_GetMarkStateMessage_Handler,
		},
		{
			MethodName: "EndOfLog",
			Handler:    _InternalService_EndOfLog_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchFromSync",
			Handler:       _InternalService_FetchFromSync_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sandglass.proto",
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Index))
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n1, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x62
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.ProducedAt)))
	n2, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ProducedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x6a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdDuration(m.ConsumeIn)))
	n3, err := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.ConsumeIn, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if len(m.Key) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.ClusteringKey) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ClusteringKey)))
		i += copy(dAtA[i:], m.ClusteringKey)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *ProduceMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProduceMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProduceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProduceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Offsets) > 0 {
		for _, msg := range m.Offsets {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TopicConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	if m.ReplicationFactor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.ReplicationFactor))
	}
	if m.NumPartitions != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.NumPartitions))
	}
	if m.StorageDriver != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.StorageDriver))
	}
	return i, nil
}

func (m *GetTopicParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopicParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetTopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *TopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StoreLocallyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreLocallyReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FetchFromRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchFromRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.From.Size()))
	n4, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *FetchRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.From.Size()))
	n5, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.To.Size()))
	n6, err := m.To.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.ClusteringKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ClusteringKey)))
		i += copy(dAtA[i:], m.ClusteringKey)
	}
	return i, nil
}

func (m *ConsumeFromGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumeFromGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroupName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroupName)))
		i += copy(dAtA[i:], m.ConsumerGroupName)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	return i, nil
}

func (m *MarkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	if len(m.Offsets) > 0 {
		for _, msg := range m.Offsets {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.State != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.State.Size()))
		n7, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *MarkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetMarkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMarkRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n8, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *LastOffsetReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastOffsetReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n9, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *LastOffsetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastOffsetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	return i, nil
}

func (m *FetchFromSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchFromSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	return i, nil
}

func (m *HasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exists {
		dAtA[i] = 0x8
		i++
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MarkState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	if m.DeliveryCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.DeliveryCount))
	}
	return i, nil
}

func (m *EndOfLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndOfLogRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	return i, nil
}

func (m *EndOfLogReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndOfLogReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Index))
	}
	return i, nil
}

func (m *MergeState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MergeOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeOperation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Operation))
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.N != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.N))
	}
	return i, nil
}

func encodeFixed64Sandglass(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sandglass(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSandglass(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovSandglass(uint64(m.Index))
	}
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ProducedAt)
	n += 1 + l + sovSandglass(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.ConsumeIn)
	n += 1 + l + sovSandglass(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 2 + l + sovSandglass(uint64(l))
	}
	l = len(m.ClusteringKey)
	if l > 0 {
		n += 2 + l + sovSandglass(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 2 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *ProduceMessageRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *ProduceResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Offsets) > 0 {
		for _, e := range m.Offsets {
			l = e.Size()
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *TopicConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovSandglass(uint64(m.ReplicationFactor))
	}
	if m.NumPartitions != 0 {
		n += 1 + sovSandglass(uint64(m.NumPartitions))
	}
	if m.StorageDriver != 0 {
		n += 1 + sovSandglass(uint64(m.StorageDriver))
	}
	return n
}

func (m *GetTopicParams) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *GetTopicReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			l = len(s)
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *TopicReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *StoreLocallyReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *FetchFromRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.From.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *FetchRangeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.From.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = m.To.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ClusteringKey)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *ConsumeFromGroupRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroupName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *MarkRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if len(m.Offsets) > 0 {
		for _, e := range m.Offsets {
			l = e.Size()
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *MarkResponse) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *GetMarkRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *LastOffsetReply) Size() (n int) {
	var l int
	_ = l
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *LastOffsetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	return n
}

func (m *FetchFromSyncRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *HasResponse) Size() (n int) {
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	return n
}

func (m *MarkState) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	if m.DeliveryCount != 0 {
		n += 1 + sovSandglass(uint64(m.DeliveryCount))
	}
	return n
}

func (m *EndOfLogRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *EndOfLogReply) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovSandglass(uint64(m.Index))
	}
	return n
}

func (m *MergeState) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *MergeOperation) Size() (n int) {
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovSandglass(uint64(m.Operation))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	if m.N != 0 {
		n += 1 + sovSandglass(uint64(m.N))
	}
	return n
}

func sovSandglass(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSandglass(x uint64) (n int) {
	return sovSandglass(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Message{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`ProducedAt:` + strings.Replace(strings.Replace(this.ProducedAt.String(), "Timestamp", "google_protobuf1.Timestamp", 1), `&`, ``, 1) + `,`,
		`ConsumeIn:` + strings.Replace(strings.Replace(this.ConsumeIn.String(), "Duration", "google_protobuf2.Duration", 1), `&`, ``, 1) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ClusteringKey:` + fmt.Sprintf("%v", this.ClusteringKey) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProduceMessageRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProduceMessageRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "Message", "Message", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProduceResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProduceResponse{`,
		`Offsets:` + fmt.Sprintf("%v", this.Offsets) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicConfig{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`NumPartitions:` + fmt.Sprintf("%v", this.NumPartitions) + `,`,
		`StorageDriver:` + fmt.Sprintf("%v", this.StorageDriver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTopicParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTopicParams{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTopicReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTopicReply{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Partitions:` + fmt.Sprintf("%v", this.Partitions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreLocallyReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreLocallyReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchFromRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchFromRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchRangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchRangeRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ClusteringKey:` + fmt.Sprintf("%v", this.ClusteringKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsumeFromGroupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsumeFromGroupRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroupName:` + fmt.Sprintf("%v", this.ConsumerGroupName) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MarkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MarkRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Offsets:` + fmt.Sprintf("%v", this.Offsets) + `,`,
		`State:` + strings.Replace(fmt.Sprintf("%v", this.State), "MarkState", "MarkState", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MarkResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MarkResponse{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetMarkRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetMarkRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LastOffsetReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LastOffsetReply{`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LastOffsetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LastOffsetRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchFromSyncRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchFromSyncRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HasResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HasResponse{`,
		`Exists:` + fmt.Sprintf("%v", this.Exists) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MarkState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MarkState{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`DeliveryCount:` + fmt.Sprintf("%v", this.DeliveryCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndOfLogRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndOfLogRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndOfLogReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndOfLogReply{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MergeState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MergeState{`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "Message", "Message", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MergeOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MergeOperation{`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "Message", "Message", 1) + `,`,
		`N:` + fmt.Sprintf("%v", this.N) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSandglass(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ProducedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumeIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.ConsumeIn, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusteringKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusteringKey = append(m.ClusteringKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ClusteringKey == nil {
				m.ClusteringKey = []byte{}
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProduceMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProduceMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProduceMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProduceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProduceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProduceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v Offset
			m.Offsets = append(m.Offsets, v)
			if err := m.Offsets[len(m.Offsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (TopicKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPartitions", wireType)
			}
			m.NumPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPartitions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriver", wireType)
			}
			m.StorageDriver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageDriver |= (StorageDriver(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopicParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopicParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopicParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreLocallyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreLocallyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreLocallyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchFromRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchFromRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchFromRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusteringKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusteringKey = append(m.ClusteringKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ClusteringKey == nil {
				m.ClusteringKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumeFromGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumeFromGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumeFromGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v Offset
			m.Offsets = append(m.Offsets, v)
			if err := m.Offsets[len(m.Offsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &MarkState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMarkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMarkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMarkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastOffsetReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastOffsetReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastOffsetReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastOffsetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastOffsetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastOffsetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (MarkKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchFromSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchFromSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchFromSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (MarkKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCount", wireType)
			}
			m.DeliveryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndOfLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndOfLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndOfLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndOfLogReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndOfLogReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndOfLogReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= (MergeOperation_Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSandglass(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSandglass
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSandglass(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSandglass = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSandglass   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sandglass.proto", fileDescriptorSandglass) }

var fileDescriptorSandglass = []byte{
	// 1457 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0x13, 0xc9,
	0x12, 0x77, 0xc7, 0x8e, 0x1d, 0x97, 0xed, 0xc4, 0x69, 0x12, 0x18, 0x0c, 0xcf, 0xb1, 0xfa, 0x01,
	0xcf, 0x8a, 0xc0, 0x46, 0xe1, 0xf0, 0x04, 0xef, 0x09, 0x11, 0x3b, 0x84, 0x20, 0x20, 0x44, 0x13,
	0xd8, 0x95, 0x72, 0xd8, 0xd5, 0x30, 0xd3, 0x19, 0x66, 0x63, 0x4f, 0x7b, 0xa7, 0xdb, 0x2c, 0x56,
	0x84, 0xb4, 0xe2, 0xba, 0x97, 0x95, 0xf6, 0xc2, 0x69, 0xf7, 0xba, 0x77, 0xa4, 0x3d, 0xec, 0x27,
	0xe0, 0xb8, 0xd2, 0x5e, 0x56, 0x7b, 0xe0, 0x4f, 0x76, 0x3f, 0xc8, 0xaa, 0x7b, 0x66, 0xec, 0x19,
	0xdb, 0x31, 0x08, 0x5f, 0x38, 0x79, 0xba, 0xaa, 0xba, 0xfa, 0x57, 0xd5, 0xd5, 0x55, 0x3f, 0xc3,
	0x02, 0x37, 0x5c, 0xcb, 0x6e, 0x19, 0x9c, 0xd7, 0x3a, 0x1e, 0x13, 0x0c, 0x67, 0xfb, 0x82, 0xd2,
	0x59, 0x9b, 0x31, 0xbb, 0x45, 0xeb, 0x46, 0xc7, 0xa9, 0x1b, 0xae, 0xcb, 0x84, 0x21, 0x1c, 0xe6,
	0x06, 0x86, 0xa5, 0x95, 0x40, 0xab, 0x56, 0x8f, 0xba, 0xfb, 0x75, 0xe1, 0xb4, 0x29, 0x17, 0x46,
	0xbb, 0x13, 0x18, 0x94, 0x87, 0x0d, 0xac, 0xae, 0xa7, 0x3c, 0x04, 0xfa, 0x4b, 0xb6, 0x23, 0x1e,
	0x77, 0x1f, 0xd5, 0x4c, 0xd6, 0xae, 0xdb, 0xcc, 0x66, 0x03, 0x43, 0xb9, 0x52, 0x0b, 0xf5, 0xe5,
	0x9b, 0x93, 0x1f, 0x67, 0x20, 0x73, 0x8f, 0x72, 0x6e, 0xd8, 0x14, 0x2f, 0xc1, 0xac, 0xe3, 0x5a,
	0xf4, 0xa9, 0x06, 0x15, 0x54, 0x4d, 0xe9, 0xfe, 0x02, 0x5f, 0x80, 0x34, 0xdb, 0xdf, 0xe7, 0x54,
	0x68, 0xb9, 0x0a, 0xaa, 0xe6, 0x1b, 0xf3, 0xaf, 0x5e, 0xaf, 0x24, 0xfe, 0x7c, 0xbd, 0x92, 0xbe,
	0xaf, 0xa4, 0x7a, 0xa0, 0xc5, 0x1b, 0x00, 0x1d, 0x8f, 0x59, 0x5d, 0x93, 0x5a, 0xeb, 0x42, 0xcb,
	0x57, 0x50, 0x35, 0xb7, 0x56, 0xaa, 0xf9, 0x68, 0x6b, 0x21, 0x88, 0xda, 0x83, 0x30, 0x9c, 0xc6,
	0x9c, 0xf4, 0xf3, 0xfd, 0x9b, 0x15, 0xa4, 0x47, 0xf6, 0xe1, 0x75, 0xc8, 0x9a, 0xcc, 0xe5, 0xdd,
	0x36, 0xbd, 0xed, 0x6a, 0x05, 0xe5, 0xe4, 0xf4, 0x88, 0x93, 0x8d, 0x20, 0x64, 0xdf, 0xc7, 0x0b,
	0xe9, 0x63, 0xb0, 0x0b, 0x17, 0x21, 0x79, 0x40, 0x7b, 0xda, 0x92, 0x44, 0xab, 0xcb, 0x4f, 0x7c,
	0x0e, 0x0a, 0x66, 0xab, 0xcb, 0x05, 0xf5, 0x1c, 0xd7, 0xbe, 0x43, 0x7b, 0xda, 0xb2, 0xd2, 0xc5,
	0x85, 0x32, 0xfc, 0x27, 0x46, 0xab, 0x4b, 0xb5, 0xb2, 0xd2, 0xfa, 0x0b, 0x72, 0x08, 0xcb, 0x3b,
	0x3e, 0xbc, 0x20, 0x4d, 0x3a, 0xfd, 0xba, 0x4b, 0xb9, 0x90, 0xe6, 0x82, 0x75, 0x1c, 0x53, 0x43,
	0x15, 0x54, 0xcd, 0xea, 0xfe, 0x02, 0x9f, 0x85, 0x6c, 0xc7, 0xf0, 0x84, 0x23, 0xe1, 0x69, 0x33,
	0x4a, 0x33, 0x10, 0xe0, 0x1a, 0xcc, 0xb5, 0x7d, 0x2f, 0x5c, 0x4b, 0x56, 0x92, 0xd5, 0xdc, 0x1a,
	0xae, 0x0d, 0x4a, 0x25, 0x3c, 0xa0, 0x6f, 0x43, 0xfe, 0x07, 0x0b, 0xc1, 0xe1, 0x3a, 0xe5, 0x1d,
	0xe6, 0x72, 0x8a, 0xab, 0x90, 0xf1, 0x13, 0xce, 0x35, 0x54, 0x49, 0x8e, 0xb9, 0x8f, 0x50, 0x4d,
	0xde, 0x20, 0xc8, 0x3d, 0x90, 0xa0, 0x9a, 0xcc, 0xdd, 0x77, 0x6c, 0x8c, 0x21, 0xe5, 0x1a, 0x6d,
	0x1a, 0xe0, 0x55, 0xdf, 0xb8, 0x0a, 0xa9, 0x03, 0xc7, 0xb5, 0x14, 0xd2, 0xf9, 0xb5, 0xa5, 0x08,
	0x18, 0xb5, 0xf3, 0x8e, 0xe3, 0x5a, 0xba, 0xb2, 0xc0, 0x17, 0x61, 0xd1, 0xa3, 0x9d, 0x96, 0x63,
	0xaa, 0xcc, 0x6f, 0x1a, 0xa6, 0x60, 0x9e, 0x96, 0xac, 0xa0, 0xea, 0xac, 0x3e, 0xaa, 0x90, 0x19,
	0x77, 0xbb, 0xed, 0x9d, 0x30, 0x70, 0xae, 0xa5, 0x94, 0x65, 0x5c, 0x88, 0xaf, 0x43, 0x81, 0x0b,
	0xe6, 0x19, 0x36, 0xdd, 0xf0, 0x9c, 0x27, 0xd4, 0xd3, 0x66, 0x15, 0x0c, 0x2d, 0x02, 0x63, 0x37,
	0xaa, 0xd7, 0xe3, 0xe6, 0xe4, 0x1c, 0xcc, 0xdf, 0xa2, 0x42, 0x21, 0xdd, 0x31, 0x3c, 0xa3, 0xcd,
	0xc7, 0xc5, 0x48, 0x9a, 0x50, 0x08, 0xad, 0x74, 0xda, 0x69, 0xf5, 0xc6, 0x26, 0xa2, 0x0c, 0xd0,
	0x19, 0xa0, 0x9d, 0xa9, 0x24, 0xab, 0x59, 0x3d, 0x22, 0x21, 0x17, 0x00, 0x22, 0x1e, 0x34, 0xc8,
	0xf0, 0xae, 0x69, 0x52, 0xce, 0x95, 0x93, 0x39, 0x3d, 0x5c, 0x92, 0x4b, 0xb0, 0x28, 0x21, 0xd3,
	0xbb, 0xcc, 0x34, 0x5a, 0xad, 0xde, 0xfb, 0xcc, 0xbf, 0x82, 0xe2, 0x26, 0x15, 0xe6, 0xe3, 0x4d,
	0x8f, 0xb5, 0xa7, 0x29, 0x2c, 0x02, 0xa9, 0x7d, 0x8f, 0xb5, 0xd5, 0x85, 0x8c, 0x96, 0x84, 0xd2,
	0x91, 0xef, 0x10, 0x2c, 0xaa, 0xc3, 0x74, 0xc3, 0x9d, 0xae, 0x8c, 0x3f, 0xe0, 0x34, 0x5c, 0x86,
	0x19, 0xc1, 0xd4, 0xb5, 0x8f, 0x5a, 0xcc, 0x08, 0x46, 0x9e, 0x02, 0xdc, 0xa2, 0x62, 0x1a, 0x14,
	0xc1, 0x3b, 0x4f, 0x4e, 0x78, 0xe7, 0xa9, 0x31, 0xef, 0x9c, 0xfc, 0x84, 0xe0, 0x54, 0xd3, 0xef,
	0x16, 0x32, 0xed, 0xb7, 0x3c, 0xd6, 0xed, 0x4c, 0x83, 0xe3, 0x22, 0x2c, 0x06, 0xcd, 0xc7, 0x53,
	0xbe, 0xb6, 0x65, 0x6d, 0x25, 0x95, 0xd5, 0xa8, 0x02, 0x13, 0xc8, 0x87, 0x42, 0x65, 0x98, 0x52,
	0x86, 0x31, 0x19, 0x79, 0x87, 0x20, 0x77, 0xcf, 0xf0, 0x0e, 0xa6, 0x41, 0x25, 0x73, 0x11, 0x3d,
	0x3c, 0x40, 0x14, 0x17, 0x7e, 0x08, 0x9a, 0x68, 0xc7, 0x99, 0x9d, 0xd8, 0x71, 0xf0, 0x2a, 0xcc,
	0x72, 0x61, 0x08, 0xaa, 0xa5, 0x55, 0xe3, 0x8e, 0xb6, 0x13, 0x19, 0xce, 0xae, 0xd4, 0xe9, 0xbe,
	0x09, 0xa9, 0x42, 0xde, 0x0f, 0x31, 0xe8, 0x6b, 0xc7, 0xbf, 0x91, 0x5f, 0x90, 0x7a, 0xe6, 0x9f,
	0x4e, 0x42, 0x06, 0x13, 0x71, 0x76, 0xd2, 0x44, 0x24, 0x57, 0x61, 0xe1, 0xae, 0xc1, 0x45, 0x20,
	0x55, 0x9d, 0x60, 0xb0, 0x15, 0x4d, 0xdc, 0xfa, 0x2b, 0x82, 0xc5, 0xe8, 0xde, 0x4f, 0x21, 0xec,
	0xff, 0x04, 0xb3, 0xc2, 0x6f, 0xd2, 0x27, 0x86, 0x2e, 0x77, 0x30, 0x2a, 0xc8, 0x17, 0xb0, 0xd4,
	0x6f, 0x6a, 0xbb, 0x3d, 0xd7, 0x9c, 0x06, 0x3e, 0x8e, 0xb6, 0x9a, 0xa0, 0x91, 0x9d, 0x87, 0xdc,
	0x96, 0xc1, 0xfb, 0x95, 0x73, 0x12, 0xd2, 0xf4, 0xa9, 0xc3, 0x45, 0x58, 0x38, 0xc1, 0x8a, 0xec,
	0x41, 0xb6, 0x5f, 0x75, 0x7d, 0xf0, 0xe8, 0x3d, 0xe0, 0x65, 0xbe, 0x2c, 0xda, 0x92, 0xe3, 0xa5,
	0xd7, 0x64, 0x5d, 0x57, 0x28, 0x48, 0xb3, 0x7a, 0x5c, 0x48, 0x6e, 0xc2, 0xc2, 0x4d, 0xd7, 0xba,
	0xbf, 0x7f, 0x97, 0xd9, 0x53, 0x44, 0x47, 0xce, 0x43, 0x61, 0xe0, 0x46, 0xd6, 0x47, 0x9f, 0x82,
	0xa1, 0x08, 0x05, 0x23, 0xff, 0x07, 0xb8, 0x47, 0x3d, 0x9b, 0xfa, 0xa1, 0x44, 0x49, 0x04, 0xfa,
	0x00, 0x12, 0xf1, 0x12, 0xc1, 0xbc, 0xda, 0x7e, 0xbf, 0x43, 0x7d, 0xde, 0x24, 0x59, 0x16, 0x0b,
	0x17, 0x41, 0x4a, 0xfe, 0x1d, 0xf3, 0x11, 0xb5, 0xae, 0xf5, 0xbf, 0xf4, 0xc1, 0xae, 0x18, 0x8a,
	0x99, 0xf7, 0xa3, 0xc0, 0x79, 0x40, 0xdb, 0x01, 0x5f, 0x40, 0xdb, 0xa4, 0x02, 0xd9, 0x01, 0x1a,
	0x80, 0xf4, 0xfa, 0xce, 0xce, 0xcd, 0xed, 0x8d, 0x62, 0x02, 0x67, 0x20, 0xd9, 0x7c, 0xf8, 0xa0,
	0x88, 0x56, 0x2f, 0x40, 0xb6, 0x4f, 0x41, 0x70, 0x01, 0xb2, 0x92, 0x38, 0x7a, 0x72, 0x51, 0x4c,
	0xc8, 0x0d, 0x77, 0x3e, 0x53, 0xdf, 0x68, 0xb5, 0x0a, 0x85, 0x18, 0x47, 0xc0, 0x39, 0xc8, 0xe8,
	0xcc, 0x3c, 0xe0, 0x1b, 0x0d, 0xdf, 0xb2, 0x61, 0x58, 0x36, 0xf5, 0x8a, 0x68, 0x75, 0x0f, 0xe6,
	0xc2, 0xbb, 0x96, 0x46, 0x0f, 0xdd, 0x03, 0x97, 0x7d, 0xe3, 0x16, 0x13, 0x38, 0x0f, 0x73, 0xc1,
	0x3c, 0xb0, 0x8a, 0x80, 0x4f, 0xc0, 0xc2, 0x36, 0x13, 0xeb, 0xa6, 0xd4, 0xb6, 0xa8, 0x65, 0x53,
	0xab, 0xb8, 0x84, 0x8b, 0x90, 0x8f, 0x49, 0xca, 0xfe, 0xa6, 0x76, 0xdb, 0x11, 0xd4, 0x2a, 0x56,
	0xd7, 0x9e, 0xa7, 0xa1, 0xd0, 0xf0, 0xd8, 0x01, 0xf5, 0x76, 0xa9, 0xf7, 0xc4, 0x31, 0x29, 0xde,
	0x81, 0x5c, 0xd3, 0xa3, 0x86, 0xa0, 0x2a, 0x0a, 0x7c, 0x72, 0x98, 0x5a, 0xf9, 0xa4, 0xac, 0xb4,
	0x3c, 0x2c, 0x57, 0x75, 0x40, 0xf0, 0xf3, 0xdf, 0xff, 0xfe, 0x61, 0x26, 0x4f, 0x32, 0x75, 0x55,
	0x46, 0xfc, 0x1a, 0x5a, 0xc5, 0x9f, 0xc3, 0x5c, 0xc8, 0x63, 0xf0, 0xe9, 0xc8, 0xb6, 0x38, 0x05,
	0x2a, 0x69, 0x63, 0x54, 0xbe, 0xd3, 0x93, 0xca, 0x69, 0x11, 0xcf, 0x07, 0x4e, 0xeb, 0x87, 0x92,
	0xfa, 0x3c, 0xc3, 0xcf, 0x11, 0x64, 0x02, 0x9a, 0x89, 0x2b, 0x91, 0xdd, 0x63, 0x79, 0x6f, 0xa9,
	0x34, 0x6a, 0x11, 0x3e, 0x45, 0x72, 0x55, 0x9d, 0x70, 0x85, 0x2c, 0xf4, 0x4f, 0x50, 0xbf, 0xcf,
	0xae, 0xa1, 0xd5, 0xbd, 0x7f, 0x91, 0x33, 0x43, 0xd2, 0xfa, 0x61, 0xff, 0x25, 0x3c, 0xc3, 0x37,
	0x20, 0xdb, 0x6f, 0x1a, 0xf8, 0x4c, 0xe4, 0x8c, 0x61, 0x7e, 0x54, 0x1a, 0x53, 0x67, 0x24, 0x71,
	0x19, 0xe1, 0x06, 0xc0, 0x80, 0xde, 0xe0, 0xb3, 0xc3, 0x2e, 0xa2, 0xac, 0xe7, 0x58, 0x1f, 0x2f,
	0x11, 0x14, 0x87, 0xb9, 0x01, 0x26, 0x11, 0xe3, 0x63, 0x88, 0xc3, 0x58, 0x87, 0x54, 0x65, 0xe3,
	0x4b, 0x3c, 0x29, 0xee, 0xbd, 0x1b, 0xf8, 0xfa, 0x04, 0x75, 0xfd, 0x70, 0x84, 0x41, 0x44, 0x64,
	0x6a, 0x79, 0x19, 0xe1, 0x1b, 0x90, 0x8b, 0x54, 0x67, 0xac, 0xd6, 0x22, 0x53, 0xb3, 0x74, 0x6a,
	0x44, 0x1e, 0x5c, 0x5b, 0x02, 0x37, 0x61, 0x3e, 0x5e, 0xf4, 0x1f, 0xe1, 0x64, 0xed, 0x6d, 0x12,
	0x16, 0x6e, 0xbb, 0x82, 0x7a, 0xae, 0xd1, 0x0a, 0x9f, 0xc1, 0x7f, 0x55, 0xd1, 0x36, 0x7a, 0xf2,
	0x0f, 0xd6, 0x72, 0xbc, 0x32, 0x27, 0xde, 0x05, 0xbe, 0x0a, 0xe9, 0x2d, 0x83, 0x4f, 0xd8, 0x16,
	0x05, 0x18, 0x19, 0x07, 0x24, 0x81, 0xb7, 0xa0, 0x10, 0x9b, 0x3f, 0x78, 0x65, 0x5c, 0x39, 0x45,
	0x26, 0xd3, 0xb1, 0xe5, 0xb0, 0x05, 0x30, 0x98, 0xc2, 0xb1, 0x92, 0x1a, 0x19, 0xce, 0xb1, 0x77,
	0x31, 0x34, 0xf6, 0x55, 0x38, 0x29, 0x99, 0xad, 0x8f, 0xb9, 0x9b, 0x4d, 0x38, 0x11, 0xd0, 0x1f,
	0xd5, 0xff, 0xc3, 0x7f, 0xeb, 0x43, 0x2d, 0x20, 0xea, 0x6c, 0x7c, 0x46, 0x1b, 0x30, 0x17, 0x0e,
	0x1b, 0x1c, 0x05, 0x3b, 0x34, 0xc8, 0x62, 0x0d, 0x24, 0x36, 0x9d, 0x48, 0xa2, 0x71, 0xfe, 0x8f,
	0x77, 0xe5, 0xc4, 0xb7, 0x47, 0x65, 0xf4, 0xf3, 0x51, 0x19, 0xbd, 0x3a, 0x2a, 0xa3, 0xdf, 0x8e,
	0xca, 0xe8, 0xed, 0x51, 0x19, 0xbd, 0xf8, 0xab, 0x9c, 0xd8, 0xcb, 0x70, 0xdb, 0xff, 0x8f, 0x9e,
	0x56, 0x3f, 0x57, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x19, 0x92, 0xf3, 0x60, 0x08, 0x11, 0x00,
	0x00,
}
