// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sandglass.proto

/*
	Package sgproto is a generated protocol buffer package.

	It is generated from these files:
		sandglass.proto

	It has these top-level messages:
		Message
		DUIDReply
		CreateTopicParams
		GetTopicParams
		GetTopicReply
		TopicReply
		StoreLocallyReply
		FetchFromRequest
		FetchRangeRequest
		GetRequest
		ConsumeFromGroupRequest
		OffsetChangeRequest
		MultiOffsetChangeRequest
		OffsetChangeReply
		LastOffsetReply
		LastOffsetRequest
		FetchFromSyncRequest
		HasResponse
		MarkState
		SyncRequest
		SyncResponse
*/
package sgproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_celrenheit_sandflake "github.com/celrenheit/sandflake"

import bytes "bytes"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TopicKind int32

const (
	TopicKind_TimerKind TopicKind = 0
	TopicKind_KVKind    TopicKind = 1
)

var TopicKind_name = map[int32]string{
	0: "TimerKind",
	1: "KVKind",
}
var TopicKind_value = map[string]int32{
	"TimerKind": 0,
	"KVKind":    1,
}

func (x TopicKind) String() string {
	return proto.EnumName(TopicKind_name, int32(x))
}
func (TopicKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{0} }

type StorageDriver int32

const (
	StorageDriver_RocksDB StorageDriver = 0
	StorageDriver_Badger  StorageDriver = 1
)

var StorageDriver_name = map[int32]string{
	0: "RocksDB",
	1: "Badger",
}
var StorageDriver_value = map[string]int32{
	"RocksDB": 0,
	"Badger":  1,
}

func (x StorageDriver) String() string {
	return proto.EnumName(StorageDriver_name, int32(x))
}
func (StorageDriver) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{1} }

type ConsistencyLevel int32

const (
	ConsistencyLevel_ONE    ConsistencyLevel = 0
	ConsistencyLevel_QUORUM ConsistencyLevel = 10
	ConsistencyLevel_ALL    ConsistencyLevel = 20
)

var ConsistencyLevel_name = map[int32]string{
	0:  "ONE",
	10: "QUORUM",
	20: "ALL",
}
var ConsistencyLevel_value = map[string]int32{
	"ONE":    0,
	"QUORUM": 10,
	"ALL":    20,
}

func (x ConsistencyLevel) String() string {
	return proto.EnumName(ConsistencyLevel_name, int32(x))
}
func (ConsistencyLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{2} }

type MarkKind int32

const (
	MarkKind_Unknown         MarkKind = 0
	MarkKind_Consumed        MarkKind = 10
	MarkKind_NotAcknowledged MarkKind = 20
	MarkKind_Acknowledged    MarkKind = 30
	MarkKind_Commited        MarkKind = 40
)

var MarkKind_name = map[int32]string{
	0:  "Unknown",
	10: "Consumed",
	20: "NotAcknowledged",
	30: "Acknowledged",
	40: "Commited",
}
var MarkKind_value = map[string]int32{
	"Unknown":         0,
	"Consumed":        10,
	"NotAcknowledged": 20,
	"Acknowledged":    30,
	"Commited":        40,
}

func (x MarkKind) String() string {
	return proto.EnumName(MarkKind_name, int32(x))
}
func (MarkKind) EnumDescriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{3} }

type Message struct {
	Topic         string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Index         github_com_celrenheit_sandflake.ID `protobuf:"bytes,10,opt,name=index,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"index"`
	Offset        github_com_celrenheit_sandflake.ID `protobuf:"bytes,11,opt,name=offset,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"offset"`
	Key           []byte                             `protobuf:"bytes,20,opt,name=key,proto3" json:"key,omitempty"`
	ClusteringKey []byte                             `protobuf:"bytes,21,opt,name=clusteringKey,proto3" json:"clusteringKey,omitempty"`
	Value         []byte                             `protobuf:"bytes,30,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{0} }

func (m *Message) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Message) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *Message) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Message) GetClusteringKey() []byte {
	if m != nil {
		return m.ClusteringKey
	}
	return nil
}

func (m *Message) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type DUIDReply struct {
	Id github_com_celrenheit_sandflake.ID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"id"`
}

func (m *DUIDReply) Reset()                    { *m = DUIDReply{} }
func (*DUIDReply) ProtoMessage()               {}
func (*DUIDReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{1} }

type CreateTopicParams struct {
	Name              string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind              TopicKind     `protobuf:"varint,2,opt,name=kind,proto3,enum=sandglass.TopicKind" json:"kind,omitempty"`
	ReplicationFactor int32         `protobuf:"varint,3,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	NumPartitions     int32         `protobuf:"varint,4,opt,name=numPartitions,proto3" json:"numPartitions,omitempty"`
	StorageDriver     StorageDriver `protobuf:"varint,5,opt,name=storageDriver,proto3,enum=sandglass.StorageDriver" json:"storageDriver,omitempty"`
}

func (m *CreateTopicParams) Reset()                    { *m = CreateTopicParams{} }
func (*CreateTopicParams) ProtoMessage()               {}
func (*CreateTopicParams) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{2} }

func (m *CreateTopicParams) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateTopicParams) GetKind() TopicKind {
	if m != nil {
		return m.Kind
	}
	return TopicKind_TimerKind
}

func (m *CreateTopicParams) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *CreateTopicParams) GetNumPartitions() int32 {
	if m != nil {
		return m.NumPartitions
	}
	return 0
}

func (m *CreateTopicParams) GetStorageDriver() StorageDriver {
	if m != nil {
		return m.StorageDriver
	}
	return StorageDriver_RocksDB
}

type GetTopicParams struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetTopicParams) Reset()                    { *m = GetTopicParams{} }
func (*GetTopicParams) ProtoMessage()               {}
func (*GetTopicParams) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{3} }

func (m *GetTopicParams) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetTopicReply struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Partitions []string `protobuf:"bytes,2,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *GetTopicReply) Reset()                    { *m = GetTopicReply{} }
func (*GetTopicReply) ProtoMessage()               {}
func (*GetTopicReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{4} }

func (m *GetTopicReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetTopicReply) GetPartitions() []string {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type TopicReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *TopicReply) Reset()                    { *m = TopicReply{} }
func (*TopicReply) ProtoMessage()               {}
func (*TopicReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{5} }

func (m *TopicReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type StoreLocallyReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *StoreLocallyReply) Reset()                    { *m = StoreLocallyReply{} }
func (*StoreLocallyReply) ProtoMessage()               {}
func (*StoreLocallyReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{6} }

func (m *StoreLocallyReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type FetchFromRequest struct {
	Topic     string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      github_com_celrenheit_sandflake.ID `protobuf:"bytes,3,opt,name=from,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"from"`
}

func (m *FetchFromRequest) Reset()                    { *m = FetchFromRequest{} }
func (*FetchFromRequest) ProtoMessage()               {}
func (*FetchFromRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{7} }

func (m *FetchFromRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchFromRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type FetchRangeRequest struct {
	Topic     string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      github_com_celrenheit_sandflake.ID `protobuf:"bytes,3,opt,name=from,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"from"`
	To        github_com_celrenheit_sandflake.ID `protobuf:"bytes,4,opt,name=to,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"to"`
}

func (m *FetchRangeRequest) Reset()                    { *m = FetchRangeRequest{} }
func (*FetchRangeRequest) ProtoMessage()               {}
func (*FetchRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{8} }

func (m *FetchRangeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchRangeRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type GetRequest struct {
	Topic         string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Key           []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	ClusteringKey []byte `protobuf:"bytes,4,opt,name=clusteringKey,proto3" json:"clusteringKey,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{9} }

func (m *GetRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *GetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *GetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GetRequest) GetClusteringKey() []byte {
	if m != nil {
		return m.ClusteringKey
	}
	return nil
}

type ConsumeFromGroupRequest struct {
	Topic             string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition         string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroupName string `protobuf:"bytes,3,opt,name=consumerGroupName,proto3" json:"consumerGroupName,omitempty"`
	ConsumerName      string `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
}

func (m *ConsumeFromGroupRequest) Reset()      { *m = ConsumeFromGroupRequest{} }
func (*ConsumeFromGroupRequest) ProtoMessage() {}
func (*ConsumeFromGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{10}
}

func (m *ConsumeFromGroupRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetConsumerGroupName() string {
	if m != nil {
		return m.ConsumerGroupName
	}
	return ""
}

func (m *ConsumeFromGroupRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type OffsetChangeRequest struct {
	Topic         string                             `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string                             `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string                             `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string                             `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Offset        github_com_celrenheit_sandflake.ID `protobuf:"bytes,5,opt,name=offset,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"offset"`
}

func (m *OffsetChangeRequest) Reset()                    { *m = OffsetChangeRequest{} }
func (*OffsetChangeRequest) ProtoMessage()               {}
func (*OffsetChangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{11} }

func (m *OffsetChangeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *OffsetChangeRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *OffsetChangeRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *OffsetChangeRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type MultiOffsetChangeRequest struct {
	Topic         string                               `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string                               `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string                               `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string                               `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Offsets       []github_com_celrenheit_sandflake.ID `protobuf:"bytes,5,rep,name=offsets,customtype=github.com/celrenheit/sandflake.ID" json:"offsets"`
}

func (m *MultiOffsetChangeRequest) Reset()      { *m = MultiOffsetChangeRequest{} }
func (*MultiOffsetChangeRequest) ProtoMessage() {}
func (*MultiOffsetChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{12}
}

func (m *MultiOffsetChangeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *MultiOffsetChangeRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *MultiOffsetChangeRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *MultiOffsetChangeRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

type OffsetChangeReply struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *OffsetChangeReply) Reset()                    { *m = OffsetChangeReply{} }
func (*OffsetChangeReply) ProtoMessage()               {}
func (*OffsetChangeReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{13} }

func (m *OffsetChangeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type LastOffsetReply struct {
	Offset github_com_celrenheit_sandflake.ID `protobuf:"bytes,1,opt,name=offset,proto3,customtype=github.com/celrenheit/sandflake.ID" json:"offset"`
}

func (m *LastOffsetReply) Reset()                    { *m = LastOffsetReply{} }
func (*LastOffsetReply) ProtoMessage()               {}
func (*LastOffsetReply) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{14} }

type LastOffsetRequest struct {
	Topic         string   `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition     string   `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ConsumerGroup string   `protobuf:"bytes,3,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	ConsumerName  string   `protobuf:"bytes,4,opt,name=consumerName,proto3" json:"consumerName,omitempty"`
	Kind          MarkKind `protobuf:"varint,5,opt,name=kind,proto3,enum=sandglass.MarkKind" json:"kind,omitempty"`
}

func (m *LastOffsetRequest) Reset()                    { *m = LastOffsetRequest{} }
func (*LastOffsetRequest) ProtoMessage()               {}
func (*LastOffsetRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{15} }

func (m *LastOffsetRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *LastOffsetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *LastOffsetRequest) GetConsumerGroup() string {
	if m != nil {
		return m.ConsumerGroup
	}
	return ""
}

func (m *LastOffsetRequest) GetConsumerName() string {
	if m != nil {
		return m.ConsumerName
	}
	return ""
}

func (m *LastOffsetRequest) GetKind() MarkKind {
	if m != nil {
		return m.Kind
	}
	return MarkKind_Unknown
}

type FetchFromSyncRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	From      []byte `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *FetchFromSyncRequest) Reset()                    { *m = FetchFromSyncRequest{} }
func (*FetchFromSyncRequest) ProtoMessage()               {}
func (*FetchFromSyncRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{16} }

func (m *FetchFromSyncRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *FetchFromSyncRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *FetchFromSyncRequest) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

type HasResponse struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
}

func (m *HasResponse) Reset()                    { *m = HasResponse{} }
func (*HasResponse) ProtoMessage()               {}
func (*HasResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{17} }

func (m *HasResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type MarkState struct {
	Kind          MarkKind `protobuf:"varint,1,opt,name=kind,proto3,enum=sandglass.MarkKind" json:"kind,omitempty"`
	DeliveryCount int32    `protobuf:"varint,2,opt,name=deliveryCount,proto3" json:"deliveryCount,omitempty"`
}

func (m *MarkState) Reset()                    { *m = MarkState{} }
func (*MarkState) ProtoMessage()               {}
func (*MarkState) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{18} }

func (m *MarkState) GetKind() MarkKind {
	if m != nil {
		return m.Kind
	}
	return MarkKind_Unknown
}

func (m *MarkState) GetDeliveryCount() int32 {
	if m != nil {
		return m.DeliveryCount
	}
	return 0
}

type SyncRequest struct {
	Topics map[string]*SyncRequest_SyncRequestTopic `protobuf:"bytes,1,rep,name=topics" json:"topics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncRequest) Reset()                    { *m = SyncRequest{} }
func (*SyncRequest) ProtoMessage()               {}
func (*SyncRequest) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{19} }

func (m *SyncRequest) GetTopics() map[string]*SyncRequest_SyncRequestTopic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type SyncRequest_SyncRequestTopic struct {
	Partitions []string `protobuf:"bytes,1,rep,name=partitions" json:"partitions,omitempty"`
}

func (m *SyncRequest_SyncRequestTopic) Reset()      { *m = SyncRequest_SyncRequestTopic{} }
func (*SyncRequest_SyncRequestTopic) ProtoMessage() {}
func (*SyncRequest_SyncRequestTopic) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{19, 0}
}

func (m *SyncRequest_SyncRequestTopic) GetPartitions() []string {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type SyncResponse struct {
	Topics map[string]*SyncResponse_SyncResponseTopic `protobuf:"bytes,1,rep,name=topics" json:"topics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncResponse) Reset()                    { *m = SyncResponse{} }
func (*SyncResponse) ProtoMessage()               {}
func (*SyncResponse) Descriptor() ([]byte, []int) { return fileDescriptorSandglass, []int{20} }

func (m *SyncResponse) GetTopics() map[string]*SyncResponse_SyncResponseTopic {
	if m != nil {
		return m.Topics
	}
	return nil
}

type SyncResponse_SyncResponseTopic struct {
	Partitions map[string]*Message `protobuf:"bytes,1,rep,name=partitions" json:"partitions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SyncResponse_SyncResponseTopic) Reset()      { *m = SyncResponse_SyncResponseTopic{} }
func (*SyncResponse_SyncResponseTopic) ProtoMessage() {}
func (*SyncResponse_SyncResponseTopic) Descriptor() ([]byte, []int) {
	return fileDescriptorSandglass, []int{20, 0}
}

func (m *SyncResponse_SyncResponseTopic) GetPartitions() map[string]*Message {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func init() {
	proto.RegisterType((*Message)(nil), "sandglass.Message")
	proto.RegisterType((*DUIDReply)(nil), "sandglass.DUIDReply")
	proto.RegisterType((*CreateTopicParams)(nil), "sandglass.CreateTopicParams")
	proto.RegisterType((*GetTopicParams)(nil), "sandglass.GetTopicParams")
	proto.RegisterType((*GetTopicReply)(nil), "sandglass.GetTopicReply")
	proto.RegisterType((*TopicReply)(nil), "sandglass.TopicReply")
	proto.RegisterType((*StoreLocallyReply)(nil), "sandglass.StoreLocallyReply")
	proto.RegisterType((*FetchFromRequest)(nil), "sandglass.FetchFromRequest")
	proto.RegisterType((*FetchRangeRequest)(nil), "sandglass.FetchRangeRequest")
	proto.RegisterType((*GetRequest)(nil), "sandglass.GetRequest")
	proto.RegisterType((*ConsumeFromGroupRequest)(nil), "sandglass.ConsumeFromGroupRequest")
	proto.RegisterType((*OffsetChangeRequest)(nil), "sandglass.OffsetChangeRequest")
	proto.RegisterType((*MultiOffsetChangeRequest)(nil), "sandglass.MultiOffsetChangeRequest")
	proto.RegisterType((*OffsetChangeReply)(nil), "sandglass.OffsetChangeReply")
	proto.RegisterType((*LastOffsetReply)(nil), "sandglass.LastOffsetReply")
	proto.RegisterType((*LastOffsetRequest)(nil), "sandglass.LastOffsetRequest")
	proto.RegisterType((*FetchFromSyncRequest)(nil), "sandglass.FetchFromSyncRequest")
	proto.RegisterType((*HasResponse)(nil), "sandglass.HasResponse")
	proto.RegisterType((*MarkState)(nil), "sandglass.MarkState")
	proto.RegisterType((*SyncRequest)(nil), "sandglass.SyncRequest")
	proto.RegisterType((*SyncRequest_SyncRequestTopic)(nil), "sandglass.SyncRequest.SyncRequestTopic")
	proto.RegisterType((*SyncResponse)(nil), "sandglass.SyncResponse")
	proto.RegisterType((*SyncResponse_SyncResponseTopic)(nil), "sandglass.SyncResponse.SyncResponseTopic")
	proto.RegisterEnum("sandglass.TopicKind", TopicKind_name, TopicKind_value)
	proto.RegisterEnum("sandglass.StorageDriver", StorageDriver_name, StorageDriver_value)
	proto.RegisterEnum("sandglass.ConsistencyLevel", ConsistencyLevel_name, ConsistencyLevel_value)
	proto.RegisterEnum("sandglass.MarkKind", MarkKind_name, MarkKind_value)
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.Index.Equal(that1.Index) {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.ClusteringKey, that1.ClusteringKey) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	return true
}
func (this *DUIDReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DUIDReply)
	if !ok {
		that2, ok := that.(DUIDReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *CreateTopicParams) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CreateTopicParams)
	if !ok {
		that2, ok := that.(CreateTopicParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if this.NumPartitions != that1.NumPartitions {
		return false
	}
	if this.StorageDriver != that1.StorageDriver {
		return false
	}
	return true
}
func (this *GetTopicParams) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetTopicParams)
	if !ok {
		that2, ok := that.(GetTopicParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GetTopicReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetTopicReply)
	if !ok {
		that2, ok := that.(GetTopicReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if this.Partitions[i] != that1.Partitions[i] {
			return false
		}
	}
	return true
}
func (this *TopicReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TopicReply)
	if !ok {
		that2, ok := that.(TopicReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *StoreLocallyReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*StoreLocallyReply)
	if !ok {
		that2, ok := that.(StoreLocallyReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *FetchFromRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchFromRequest)
	if !ok {
		that2, ok := that.(FetchFromRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	return true
}
func (this *FetchRangeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchRangeRequest)
	if !ok {
		that2, ok := that.(FetchRangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	return true
}
func (this *GetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetRequest)
	if !ok {
		that2, ok := that.(GetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes.Equal(this.ClusteringKey, that1.ClusteringKey) {
		return false
	}
	return true
}
func (this *ConsumeFromGroupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ConsumeFromGroupRequest)
	if !ok {
		that2, ok := that.(ConsumeFromGroupRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroupName != that1.ConsumerGroupName {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	return true
}
func (this *OffsetChangeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OffsetChangeRequest)
	if !ok {
		that2, ok := that.(OffsetChangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	return true
}
func (this *MultiOffsetChangeRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MultiOffsetChangeRequest)
	if !ok {
		that2, ok := that.(MultiOffsetChangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if len(this.Offsets) != len(that1.Offsets) {
		return false
	}
	for i := range this.Offsets {
		if !this.Offsets[i].Equal(that1.Offsets[i]) {
			return false
		}
	}
	return true
}
func (this *OffsetChangeReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OffsetChangeReply)
	if !ok {
		that2, ok := that.(OffsetChangeReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *LastOffsetReply) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LastOffsetReply)
	if !ok {
		that2, ok := that.(LastOffsetReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Offset.Equal(that1.Offset) {
		return false
	}
	return true
}
func (this *LastOffsetRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LastOffsetRequest)
	if !ok {
		that2, ok := that.(LastOffsetRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if this.ConsumerGroup != that1.ConsumerGroup {
		return false
	}
	if this.ConsumerName != that1.ConsumerName {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	return true
}
func (this *FetchFromSyncRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FetchFromSyncRequest)
	if !ok {
		that2, ok := that.(FetchFromSyncRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Topic != that1.Topic {
		return false
	}
	if this.Partition != that1.Partition {
		return false
	}
	if !bytes.Equal(this.From, that1.From) {
		return false
	}
	return true
}
func (this *HasResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HasResponse)
	if !ok {
		that2, ok := that.(HasResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Exists != that1.Exists {
		return false
	}
	return true
}
func (this *MarkState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MarkState)
	if !ok {
		that2, ok := that.(MarkState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.DeliveryCount != that1.DeliveryCount {
		return false
	}
	return true
}
func (this *SyncRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncRequest)
	if !ok {
		that2, ok := that.(SyncRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if !this.Topics[i].Equal(that1.Topics[i]) {
			return false
		}
	}
	return true
}
func (this *SyncRequest_SyncRequestTopic) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncRequest_SyncRequestTopic)
	if !ok {
		that2, ok := that.(SyncRequest_SyncRequestTopic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if this.Partitions[i] != that1.Partitions[i] {
			return false
		}
	}
	return true
}
func (this *SyncResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncResponse)
	if !ok {
		that2, ok := that.(SyncResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if !this.Topics[i].Equal(that1.Topics[i]) {
			return false
		}
	}
	return true
}
func (this *SyncResponse_SyncResponseTopic) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SyncResponse_SyncResponseTopic)
	if !ok {
		that2, ok := that.(SyncResponse_SyncResponseTopic)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Partitions) != len(that1.Partitions) {
		return false
	}
	for i := range this.Partitions {
		if !this.Partitions[i].Equal(that1.Partitions[i]) {
			return false
		}
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BrokerService service

type BrokerServiceClient interface {
	CreateTopic(ctx context.Context, in *CreateTopicParams, opts ...grpc.CallOption) (*TopicReply, error)
	PublishMessagesStream(ctx context.Context, opts ...grpc.CallOption) (BrokerService_PublishMessagesStreamClient, error)
	GetTopic(ctx context.Context, in *GetTopicParams, opts ...grpc.CallOption) (*GetTopicReply, error)
	Publish(ctx context.Context, in *Message, opts ...grpc.CallOption) (*DUIDReply, error)
	FetchFrom(ctx context.Context, in *FetchFromRequest, opts ...grpc.CallOption) (BrokerService_FetchFromClient, error)
	FetchRange(ctx context.Context, in *FetchRangeRequest, opts ...grpc.CallOption) (BrokerService_FetchRangeClient, error)
	StoreMessagesStream(ctx context.Context, opts ...grpc.CallOption) (BrokerService_StoreMessagesStreamClient, error)
	ConsumeFromGroup(ctx context.Context, in *ConsumeFromGroupRequest, opts ...grpc.CallOption) (BrokerService_ConsumeFromGroupClient, error)
	Acknowledge(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error)
	AcknowledgeMessages(ctx context.Context, in *MultiOffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error)
	Commit(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error)
}

type brokerServiceClient struct {
	cc *grpc.ClientConn
}

func NewBrokerServiceClient(cc *grpc.ClientConn) BrokerServiceClient {
	return &brokerServiceClient{cc}
}

func (c *brokerServiceClient) CreateTopic(ctx context.Context, in *CreateTopicParams, opts ...grpc.CallOption) (*TopicReply, error) {
	out := new(TopicReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/CreateTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) PublishMessagesStream(ctx context.Context, opts ...grpc.CallOption) (BrokerService_PublishMessagesStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[0], c.cc, "/sandglass.BrokerService/PublishMessagesStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServicePublishMessagesStreamClient{stream}
	return x, nil
}

type BrokerService_PublishMessagesStreamClient interface {
	Send(*Message) error
	CloseAndRecv() (*StoreLocallyReply, error)
	grpc.ClientStream
}

type brokerServicePublishMessagesStreamClient struct {
	grpc.ClientStream
}

func (x *brokerServicePublishMessagesStreamClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerServicePublishMessagesStreamClient) CloseAndRecv() (*StoreLocallyReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StoreLocallyReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) GetTopic(ctx context.Context, in *GetTopicParams, opts ...grpc.CallOption) (*GetTopicReply, error) {
	out := new(GetTopicReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/GetTopic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Publish(ctx context.Context, in *Message, opts ...grpc.CallOption) (*DUIDReply, error) {
	out := new(DUIDReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) FetchFrom(ctx context.Context, in *FetchFromRequest, opts ...grpc.CallOption) (BrokerService_FetchFromClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[1], c.cc, "/sandglass.BrokerService/FetchFrom", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchFromClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchFromClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchFromClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchFromClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) FetchRange(ctx context.Context, in *FetchRangeRequest, opts ...grpc.CallOption) (BrokerService_FetchRangeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[2], c.cc, "/sandglass.BrokerService/FetchRange", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceFetchRangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_FetchRangeClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceFetchRangeClient struct {
	grpc.ClientStream
}

func (x *brokerServiceFetchRangeClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) StoreMessagesStream(ctx context.Context, opts ...grpc.CallOption) (BrokerService_StoreMessagesStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[3], c.cc, "/sandglass.BrokerService/StoreMessagesStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceStoreMessagesStreamClient{stream}
	return x, nil
}

type BrokerService_StoreMessagesStreamClient interface {
	Send(*Message) error
	CloseAndRecv() (*StoreLocallyReply, error)
	grpc.ClientStream
}

type brokerServiceStoreMessagesStreamClient struct {
	grpc.ClientStream
}

func (x *brokerServiceStoreMessagesStreamClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerServiceStoreMessagesStreamClient) CloseAndRecv() (*StoreLocallyReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StoreLocallyReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) ConsumeFromGroup(ctx context.Context, in *ConsumeFromGroupRequest, opts ...grpc.CallOption) (BrokerService_ConsumeFromGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BrokerService_serviceDesc.Streams[4], c.cc, "/sandglass.BrokerService/ConsumeFromGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerServiceConsumeFromGroupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BrokerService_ConsumeFromGroupClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type brokerServiceConsumeFromGroupClient struct {
	grpc.ClientStream
}

func (x *brokerServiceConsumeFromGroupClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerServiceClient) Acknowledge(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error) {
	out := new(OffsetChangeReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Acknowledge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) AcknowledgeMessages(ctx context.Context, in *MultiOffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error) {
	out := new(OffsetChangeReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/AcknowledgeMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerServiceClient) Commit(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error) {
	out := new(OffsetChangeReply)
	err := grpc.Invoke(ctx, "/sandglass.BrokerService/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BrokerService service

type BrokerServiceServer interface {
	CreateTopic(context.Context, *CreateTopicParams) (*TopicReply, error)
	PublishMessagesStream(BrokerService_PublishMessagesStreamServer) error
	GetTopic(context.Context, *GetTopicParams) (*GetTopicReply, error)
	Publish(context.Context, *Message) (*DUIDReply, error)
	FetchFrom(*FetchFromRequest, BrokerService_FetchFromServer) error
	FetchRange(*FetchRangeRequest, BrokerService_FetchRangeServer) error
	StoreMessagesStream(BrokerService_StoreMessagesStreamServer) error
	ConsumeFromGroup(*ConsumeFromGroupRequest, BrokerService_ConsumeFromGroupServer) error
	Acknowledge(context.Context, *OffsetChangeRequest) (*OffsetChangeReply, error)
	AcknowledgeMessages(context.Context, *MultiOffsetChangeRequest) (*OffsetChangeReply, error)
	Commit(context.Context, *OffsetChangeRequest) (*OffsetChangeReply, error)
}

func RegisterBrokerServiceServer(s *grpc.Server, srv BrokerServiceServer) {
	s.RegisterService(&_BrokerService_serviceDesc, srv)
}

func _BrokerService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).CreateTopic(ctx, req.(*CreateTopicParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_PublishMessagesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServiceServer).PublishMessagesStream(&brokerServicePublishMessagesStreamServer{stream})
}

type BrokerService_PublishMessagesStreamServer interface {
	SendAndClose(*StoreLocallyReply) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type brokerServicePublishMessagesStreamServer struct {
	grpc.ServerStream
}

func (x *brokerServicePublishMessagesStreamServer) SendAndClose(m *StoreLocallyReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerServicePublishMessagesStreamServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BrokerService_GetTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).GetTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/GetTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).GetTopic(ctx, req.(*GetTopicParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Publish(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_FetchFrom_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchFromRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchFrom(m, &brokerServiceFetchFromServer{stream})
}

type BrokerService_FetchFromServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchFromServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchFromServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_FetchRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).FetchRange(m, &brokerServiceFetchRangeServer{stream})
}

type BrokerService_FetchRangeServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceFetchRangeServer struct {
	grpc.ServerStream
}

func (x *brokerServiceFetchRangeServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_StoreMessagesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServiceServer).StoreMessagesStream(&brokerServiceStoreMessagesStreamServer{stream})
}

type BrokerService_StoreMessagesStreamServer interface {
	SendAndClose(*StoreLocallyReply) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type brokerServiceStoreMessagesStreamServer struct {
	grpc.ServerStream
}

func (x *brokerServiceStoreMessagesStreamServer) SendAndClose(m *StoreLocallyReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerServiceStoreMessagesStreamServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BrokerService_ConsumeFromGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsumeFromGroupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServiceServer).ConsumeFromGroup(m, &brokerServiceConsumeFromGroupServer{stream})
}

type BrokerService_ConsumeFromGroupServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type brokerServiceConsumeFromGroupServer struct {
	grpc.ServerStream
}

func (x *brokerServiceConsumeFromGroupServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _BrokerService_Acknowledge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Acknowledge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Acknowledge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Acknowledge(ctx, req.(*OffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_AcknowledgeMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiOffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).AcknowledgeMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/AcknowledgeMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).AcknowledgeMessages(ctx, req.(*MultiOffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BrokerService_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServiceServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.BrokerService/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServiceServer).Commit(ctx, req.(*OffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BrokerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sandglass.BrokerService",
	HandlerType: (*BrokerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTopic",
			Handler:    _BrokerService_CreateTopic_Handler,
		},
		{
			MethodName: "GetTopic",
			Handler:    _BrokerService_GetTopic_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _BrokerService_Publish_Handler,
		},
		{
			MethodName: "Acknowledge",
			Handler:    _BrokerService_Acknowledge_Handler,
		},
		{
			MethodName: "AcknowledgeMessages",
			Handler:    _BrokerService_AcknowledgeMessages_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _BrokerService_Commit_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PublishMessagesStream",
			Handler:       _BrokerService_PublishMessagesStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FetchFrom",
			Handler:       _BrokerService_FetchFrom_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FetchRange",
			Handler:       _BrokerService_FetchRange_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StoreMessagesStream",
			Handler:       _BrokerService_StoreMessagesStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ConsumeFromGroup",
			Handler:       _BrokerService_ConsumeFromGroup_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sandglass.proto",
}

// Client API for InternalService service

type InternalServiceClient interface {
	StoreMessageLocally(ctx context.Context, in *Message, opts ...grpc.CallOption) (*StoreLocallyReply, error)
	GetByKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Message, error)
	HasKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*HasResponse, error)
	FetchFromSync(ctx context.Context, in *FetchFromSyncRequest, opts ...grpc.CallOption) (InternalService_FetchFromSyncClient, error)
	LastOffset(ctx context.Context, in *LastOffsetRequest, opts ...grpc.CallOption) (*LastOffsetReply, error)
	MarkConsumed(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error)
	GetMarkStateMessage(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*Message, error)
}

type internalServiceClient struct {
	cc *grpc.ClientConn
}

func NewInternalServiceClient(cc *grpc.ClientConn) InternalServiceClient {
	return &internalServiceClient{cc}
}

func (c *internalServiceClient) StoreMessageLocally(ctx context.Context, in *Message, opts ...grpc.CallOption) (*StoreLocallyReply, error) {
	out := new(StoreLocallyReply)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/StoreMessageLocally", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) GetByKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/GetByKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) HasKey(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*HasResponse, error) {
	out := new(HasResponse)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/HasKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) FetchFromSync(ctx context.Context, in *FetchFromSyncRequest, opts ...grpc.CallOption) (InternalService_FetchFromSyncClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InternalService_serviceDesc.Streams[0], c.cc, "/sandglass.InternalService/FetchFromSync", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalServiceFetchFromSyncClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InternalService_FetchFromSyncClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type internalServiceFetchFromSyncClient struct {
	grpc.ClientStream
}

func (x *internalServiceFetchFromSyncClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalServiceClient) LastOffset(ctx context.Context, in *LastOffsetRequest, opts ...grpc.CallOption) (*LastOffsetReply, error) {
	out := new(LastOffsetReply)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/LastOffset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) MarkConsumed(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*OffsetChangeReply, error) {
	out := new(OffsetChangeReply)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/MarkConsumed", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalServiceClient) GetMarkStateMessage(ctx context.Context, in *OffsetChangeRequest, opts ...grpc.CallOption) (*Message, error) {
	out := new(Message)
	err := grpc.Invoke(ctx, "/sandglass.InternalService/GetMarkStateMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for InternalService service

type InternalServiceServer interface {
	StoreMessageLocally(context.Context, *Message) (*StoreLocallyReply, error)
	GetByKey(context.Context, *GetRequest) (*Message, error)
	HasKey(context.Context, *GetRequest) (*HasResponse, error)
	FetchFromSync(*FetchFromSyncRequest, InternalService_FetchFromSyncServer) error
	LastOffset(context.Context, *LastOffsetRequest) (*LastOffsetReply, error)
	MarkConsumed(context.Context, *OffsetChangeRequest) (*OffsetChangeReply, error)
	GetMarkStateMessage(context.Context, *OffsetChangeRequest) (*Message, error)
}

func RegisterInternalServiceServer(s *grpc.Server, srv InternalServiceServer) {
	s.RegisterService(&_InternalService_serviceDesc, srv)
}

func _InternalService_StoreMessageLocally_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).StoreMessageLocally(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/StoreMessageLocally",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).StoreMessageLocally(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_GetByKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetByKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/GetByKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetByKey(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_HasKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).HasKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/HasKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).HasKey(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_FetchFromSync_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchFromSyncRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServiceServer).FetchFromSync(m, &internalServiceFetchFromSyncServer{stream})
}

type InternalService_FetchFromSyncServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type internalServiceFetchFromSyncServer struct {
	grpc.ServerStream
}

func (x *internalServiceFetchFromSyncServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _InternalService_LastOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).LastOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/LastOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).LastOffset(ctx, req.(*LastOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_MarkConsumed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).MarkConsumed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/MarkConsumed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).MarkConsumed(ctx, req.(*OffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalService_GetMarkStateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OffsetChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServiceServer).GetMarkStateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sandglass.InternalService/GetMarkStateMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServiceServer).GetMarkStateMessage(ctx, req.(*OffsetChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InternalService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sandglass.InternalService",
	HandlerType: (*InternalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StoreMessageLocally",
			Handler:    _InternalService_StoreMessageLocally_Handler,
		},
		{
			MethodName: "GetByKey",
			Handler:    _InternalService_GetByKey_Handler,
		},
		{
			MethodName: "HasKey",
			Handler:    _InternalService_HasKey_Handler,
		},
		{
			MethodName: "LastOffset",
			Handler:    _InternalService_LastOffset_Handler,
		},
		{
			MethodName: "MarkConsumed",
			Handler:    _InternalService_MarkConsumed_Handler,
		},
		{
			MethodName: "GetMarkStateMessage",
			Handler:    _InternalService_GetMarkStateMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchFromSync",
			Handler:       _InternalService_FetchFromSync_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sandglass.proto",
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Index.Size()))
	n1, err := m.Index.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x5a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n2, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Key) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.ClusteringKey) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ClusteringKey)))
		i += copy(dAtA[i:], m.ClusteringKey)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *DUIDReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DUIDReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Id.Size()))
	n3, err := m.Id.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *CreateTopicParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTopicParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	if m.ReplicationFactor != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.ReplicationFactor))
	}
	if m.NumPartitions != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.NumPartitions))
	}
	if m.StorageDriver != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.StorageDriver))
	}
	return i, nil
}

func (m *GetTopicParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopicParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetTopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *TopicReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StoreLocallyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreLocallyReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *FetchFromRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchFromRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.From.Size()))
	n4, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *FetchRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.From.Size()))
	n5, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.To.Size()))
	n6, err := m.To.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.ClusteringKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ClusteringKey)))
		i += copy(dAtA[i:], m.ClusteringKey)
	}
	return i, nil
}

func (m *ConsumeFromGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumeFromGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroupName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroupName)))
		i += copy(dAtA[i:], m.ConsumerGroupName)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	return i, nil
}

func (m *OffsetChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffsetChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n7, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *MultiOffsetChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiOffsetChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	if len(m.Offsets) > 0 {
		for _, msg := range m.Offsets {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OffsetChangeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffsetChangeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LastOffsetReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastOffsetReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSandglass(dAtA, i, uint64(m.Offset.Size()))
	n8, err := m.Offset.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *LastOffsetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastOffsetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.ConsumerGroup) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerGroup)))
		i += copy(dAtA[i:], m.ConsumerGroup)
	}
	if len(m.ConsumerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.ConsumerName)))
		i += copy(dAtA[i:], m.ConsumerName)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	return i, nil
}

func (m *FetchFromSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchFromSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Topic)))
		i += copy(dAtA[i:], m.Topic)
	}
	if len(m.Partition) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.Partition)))
		i += copy(dAtA[i:], m.Partition)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	return i, nil
}

func (m *HasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exists {
		dAtA[i] = 0x8
		i++
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MarkState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.Kind))
	}
	if m.DeliveryCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSandglass(dAtA, i, uint64(m.DeliveryCount))
	}
	return i, nil
}

func (m *SyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, _ := range m.Topics {
			dAtA[i] = 0xa
			i++
			v := m.Topics[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSandglass(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSandglass(uint64(len(k))) + msgSize
			i = encodeVarintSandglass(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSandglass(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *SyncRequest_SyncRequestTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest_SyncRequestTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, _ := range m.Topics {
			dAtA[i] = 0xa
			i++
			v := m.Topics[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSandglass(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSandglass(uint64(len(k))) + msgSize
			i = encodeVarintSandglass(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSandglass(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *SyncResponse_SyncResponseTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse_SyncResponseTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for k, _ := range m.Partitions {
			dAtA[i] = 0xa
			i++
			v := m.Partitions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSandglass(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSandglass(uint64(len(k))) + msgSize
			i = encodeVarintSandglass(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSandglass(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSandglass(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func encodeFixed64Sandglass(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sandglass(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSandglass(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.Index.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 2 + l + sovSandglass(uint64(l))
	}
	l = len(m.ClusteringKey)
	if l > 0 {
		n += 2 + l + sovSandglass(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 2 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *DUIDReply) Size() (n int) {
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *CreateTopicParams) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovSandglass(uint64(m.ReplicationFactor))
	}
	if m.NumPartitions != 0 {
		n += 1 + sovSandglass(uint64(m.NumPartitions))
	}
	if m.StorageDriver != 0 {
		n += 1 + sovSandglass(uint64(m.StorageDriver))
	}
	return n
}

func (m *GetTopicParams) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *GetTopicReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			l = len(s)
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *TopicReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *StoreLocallyReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *FetchFromRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.From.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *FetchRangeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.From.Size()
	n += 1 + l + sovSandglass(uint64(l))
	l = m.To.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ClusteringKey)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *ConsumeFromGroupRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroupName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *OffsetChangeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *MultiOffsetChangeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if len(m.Offsets) > 0 {
		for _, e := range m.Offsets {
			l = e.Size()
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *OffsetChangeReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *LastOffsetReply) Size() (n int) {
	var l int
	_ = l
	l = m.Offset.Size()
	n += 1 + l + sovSandglass(uint64(l))
	return n
}

func (m *LastOffsetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerGroup)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.ConsumerName)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	return n
}

func (m *FetchFromSyncRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovSandglass(uint64(l))
	}
	return n
}

func (m *HasResponse) Size() (n int) {
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	return n
}

func (m *MarkState) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovSandglass(uint64(m.Kind))
	}
	if m.DeliveryCount != 0 {
		n += 1 + sovSandglass(uint64(m.DeliveryCount))
	}
	return n
}

func (m *SyncRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, v := range m.Topics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSandglass(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSandglass(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSandglass(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SyncRequest_SyncRequestTopic) Size() (n int) {
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for _, s := range m.Partitions {
			l = len(s)
			n += 1 + l + sovSandglass(uint64(l))
		}
	}
	return n
}

func (m *SyncResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for k, v := range m.Topics {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSandglass(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSandglass(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSandglass(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SyncResponse_SyncResponseTopic) Size() (n int) {
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for k, v := range m.Partitions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSandglass(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSandglass(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSandglass(uint64(mapEntrySize))
		}
	}
	return n
}

func sovSandglass(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSandglass(x uint64) (n int) {
	return sovSandglass(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Message{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ClusteringKey:` + fmt.Sprintf("%v", this.ClusteringKey) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DUIDReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DUIDReply{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateTopicParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateTopicParams{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`ReplicationFactor:` + fmt.Sprintf("%v", this.ReplicationFactor) + `,`,
		`NumPartitions:` + fmt.Sprintf("%v", this.NumPartitions) + `,`,
		`StorageDriver:` + fmt.Sprintf("%v", this.StorageDriver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTopicParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTopicParams{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTopicReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTopicReply{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Partitions:` + fmt.Sprintf("%v", this.Partitions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopicReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopicReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StoreLocallyReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StoreLocallyReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchFromRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchFromRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchRangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchRangeRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ClusteringKey:` + fmt.Sprintf("%v", this.ClusteringKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConsumeFromGroupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConsumeFromGroupRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroupName:` + fmt.Sprintf("%v", this.ConsumerGroupName) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OffsetChangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OffsetChangeRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiOffsetChangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultiOffsetChangeRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Offsets:` + fmt.Sprintf("%v", this.Offsets) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OffsetChangeReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OffsetChangeReply{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LastOffsetReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LastOffsetReply{`,
		`Offset:` + fmt.Sprintf("%v", this.Offset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LastOffsetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LastOffsetRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`ConsumerGroup:` + fmt.Sprintf("%v", this.ConsumerGroup) + `,`,
		`ConsumerName:` + fmt.Sprintf("%v", this.ConsumerName) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FetchFromSyncRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FetchFromSyncRequest{`,
		`Topic:` + fmt.Sprintf("%v", this.Topic) + `,`,
		`Partition:` + fmt.Sprintf("%v", this.Partition) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HasResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HasResponse{`,
		`Exists:` + fmt.Sprintf("%v", this.Exists) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MarkState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MarkState{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`DeliveryCount:` + fmt.Sprintf("%v", this.DeliveryCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForTopics := make([]string, 0, len(this.Topics))
	for k, _ := range this.Topics {
		keysForTopics = append(keysForTopics, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTopics)
	mapStringForTopics := "map[string]*SyncRequest_SyncRequestTopic{"
	for _, k := range keysForTopics {
		mapStringForTopics += fmt.Sprintf("%v: %v,", k, this.Topics[k])
	}
	mapStringForTopics += "}"
	s := strings.Join([]string{`&SyncRequest{`,
		`Topics:` + mapStringForTopics + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncRequest_SyncRequestTopic) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SyncRequest_SyncRequestTopic{`,
		`Partitions:` + fmt.Sprintf("%v", this.Partitions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForTopics := make([]string, 0, len(this.Topics))
	for k, _ := range this.Topics {
		keysForTopics = append(keysForTopics, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTopics)
	mapStringForTopics := "map[string]*SyncResponse_SyncResponseTopic{"
	for _, k := range keysForTopics {
		mapStringForTopics += fmt.Sprintf("%v: %v,", k, this.Topics[k])
	}
	mapStringForTopics += "}"
	s := strings.Join([]string{`&SyncResponse{`,
		`Topics:` + mapStringForTopics + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncResponse_SyncResponseTopic) String() string {
	if this == nil {
		return "nil"
	}
	keysForPartitions := make([]string, 0, len(this.Partitions))
	for k, _ := range this.Partitions {
		keysForPartitions = append(keysForPartitions, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPartitions)
	mapStringForPartitions := "map[string]*Message{"
	for _, k := range keysForPartitions {
		mapStringForPartitions += fmt.Sprintf("%v: %v,", k, this.Partitions[k])
	}
	mapStringForPartitions += "}"
	s := strings.Join([]string{`&SyncResponse_SyncResponseTopic{`,
		`Partitions:` + mapStringForPartitions + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSandglass(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusteringKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusteringKey = append(m.ClusteringKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ClusteringKey == nil {
				m.ClusteringKey = []byte{}
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DUIDReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DUIDReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DUIDReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTopicParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTopicParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTopicParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (TopicKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPartitions", wireType)
			}
			m.NumPartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPartitions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageDriver", wireType)
			}
			m.StorageDriver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageDriver |= (StorageDriver(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopicParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopicParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopicParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreLocallyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreLocallyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreLocallyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchFromRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchFromRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchFromRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusteringKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusteringKey = append(m.ClusteringKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ClusteringKey == nil {
				m.ClusteringKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumeFromGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumeFromGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumeFromGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OffsetChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffsetChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffsetChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiOffsetChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiOffsetChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiOffsetChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offsets", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_celrenheit_sandflake.ID
			m.Offsets = append(m.Offsets, v)
			if err := m.Offsets[len(m.Offsets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OffsetChangeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffsetChangeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffsetChangeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastOffsetReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastOffsetReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastOffsetReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastOffsetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastOffsetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastOffsetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (MarkKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchFromSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchFromSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchFromSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (MarkKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCount", wireType)
			}
			m.DeliveryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topics == nil {
				m.Topics = make(map[string]*SyncRequest_SyncRequestTopic)
			}
			var mapkey string
			var mapvalue *SyncRequest_SyncRequestTopic
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSandglass
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSandglass
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSandglass
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSandglass
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSandglass
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SyncRequest_SyncRequestTopic{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSandglass(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSandglass
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Topics[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest_SyncRequestTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequestTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequestTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topics == nil {
				m.Topics = make(map[string]*SyncResponse_SyncResponseTopic)
			}
			var mapkey string
			var mapvalue *SyncResponse_SyncResponseTopic
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSandglass
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSandglass
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSandglass
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSandglass
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSandglass
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SyncResponse_SyncResponseTopic{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSandglass(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSandglass
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Topics[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse_SyncResponseTopic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponseTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponseTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSandglass
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partitions == nil {
				m.Partitions = make(map[string]*Message)
			}
			var mapkey string
			var mapvalue *Message
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSandglass
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSandglass
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSandglass
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSandglass
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSandglass
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Message{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSandglass(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSandglass
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Partitions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSandglass(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSandglass
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSandglass(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSandglass
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSandglass
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSandglass
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSandglass
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSandglass(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSandglass = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSandglass   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sandglass.proto", fileDescriptorSandglass) }

var fileDescriptorSandglass = []byte{
	// 1541 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x4f, 0x1b, 0xd7,
	0x16, 0xf7, 0xb5, 0x01, 0xe3, 0x63, 0x08, 0xc3, 0x05, 0xf2, 0xe6, 0x39, 0x3c, 0x83, 0xee, 0xcb,
	0x87, 0x1f, 0x4a, 0x70, 0xe4, 0x2c, 0x5e, 0x43, 0x55, 0x4a, 0x0c, 0x09, 0x44, 0x7c, 0x24, 0x19,
	0x42, 0xaa, 0xb2, 0x68, 0x35, 0x8c, 0x2f, 0x66, 0xe4, 0xf1, 0x8c, 0x3b, 0x73, 0x4d, 0x63, 0x45,
	0x91, 0xaa, 0x2e, 0xba, 0xe8, 0xae, 0xea, 0xa6, 0xbb, 0x6e, 0xbb, 0xef, 0xaa, 0xd9, 0x55, 0xdd,
	0x64, 0x59, 0xa9, 0x8b, 0x56, 0x95, 0x1a, 0x35, 0xb4, 0xfd, 0x13, 0xba, 0xaf, 0xee, 0x9d, 0x19,
	0xfb, 0x8e, 0x3f, 0x70, 0x80, 0x4a, 0xcd, 0x0a, 0xdf, 0x73, 0xcf, 0x3d, 0xfe, 0x9d, 0xdf, 0x3d,
	0xf7, 0x9c, 0x1f, 0x86, 0x31, 0x4f, 0xb7, 0x4b, 0x65, 0x4b, 0xf7, 0xbc, 0xf9, 0x9a, 0xeb, 0x30,
	0x07, 0xa7, 0x9a, 0x86, 0xcc, 0x74, 0xd9, 0x71, 0xca, 0x16, 0xcd, 0xeb, 0x35, 0x33, 0xaf, 0xdb,
	0xb6, 0xc3, 0x74, 0x66, 0x3a, 0x76, 0xe0, 0x98, 0xb9, 0x56, 0x36, 0xd9, 0x41, 0x7d, 0x6f, 0xde,
	0x70, 0xaa, 0xf9, 0xb2, 0x53, 0x76, 0xf2, 0xc2, 0xbc, 0x57, 0xdf, 0x17, 0x2b, 0xb1, 0x10, 0x9f,
	0x7c, 0x77, 0xf2, 0x59, 0x1c, 0x92, 0x9b, 0xd4, 0xf3, 0xf4, 0x32, 0xc5, 0x93, 0x30, 0xc8, 0x9c,
	0x9a, 0x69, 0xa8, 0x68, 0x16, 0xe5, 0x52, 0x9a, 0xbf, 0xc0, 0xd3, 0x90, 0xaa, 0xe9, 0x2e, 0x33,
	0xf9, 0x97, 0xa8, 0x71, 0xb1, 0xd3, 0x32, 0xe0, 0x25, 0x18, 0x34, 0xed, 0x12, 0x7d, 0xac, 0xc2,
	0x2c, 0xca, 0x8d, 0x14, 0xe7, 0x9e, 0xbf, 0x98, 0x89, 0xfd, 0xfc, 0x62, 0x86, 0x48, 0x28, 0x0c,
	0x6a, 0xb9, 0xd4, 0x3e, 0xa0, 0x26, 0xcb, 0xf3, 0x24, 0xf6, 0x2d, 0xbd, 0x42, 0xe7, 0xef, 0xae,
	0x68, 0xfe, 0x41, 0x5c, 0x84, 0x21, 0x67, 0x7f, 0xdf, 0xa3, 0x4c, 0x4d, 0x9f, 0x38, 0x44, 0x70,
	0x12, 0x2b, 0x90, 0xa8, 0xd0, 0x86, 0x3a, 0xc9, 0x03, 0x68, 0xfc, 0x23, 0xbe, 0x08, 0xa3, 0x86,
	0x55, 0xf7, 0x18, 0x75, 0x4d, 0xbb, 0xbc, 0x4e, 0x1b, 0xea, 0x94, 0xd8, 0x8b, 0x1a, 0x79, 0xc6,
	0x87, 0xba, 0x55, 0xa7, 0x6a, 0x56, 0xec, 0xfa, 0x0b, 0xb2, 0x0a, 0xa9, 0x95, 0x9d, 0xbb, 0x2b,
	0x1a, 0xad, 0x59, 0x0d, 0xbc, 0x00, 0x71, 0xb3, 0x24, 0x18, 0x39, 0x19, 0xb4, 0xb8, 0x59, 0x22,
	0x7f, 0x20, 0x18, 0x5f, 0x76, 0xa9, 0xce, 0xe8, 0x43, 0x4e, 0xe5, 0x7d, 0xdd, 0xd5, 0xab, 0x1e,
	0xc6, 0x30, 0x60, 0xeb, 0x55, 0x1a, 0xb0, 0x2c, 0x3e, 0xe3, 0x1c, 0x0c, 0x54, 0x4c, 0xbb, 0x24,
	0xf8, 0x3d, 0x57, 0x98, 0x9c, 0x6f, 0x5d, 0xbf, 0x38, 0xb9, 0x6e, 0xda, 0x25, 0x4d, 0x78, 0xe0,
	0xab, 0x30, 0xee, 0xd2, 0x9a, 0x65, 0x1a, 0xe2, 0xd6, 0xef, 0xe8, 0x06, 0x73, 0x5c, 0x35, 0x31,
	0x8b, 0x72, 0x83, 0x5a, 0xe7, 0x06, 0xa7, 0xc1, 0xae, 0x57, 0xef, 0x87, 0xd7, 0xe5, 0xa9, 0x03,
	0xc2, 0x33, 0x6a, 0xc4, 0x8b, 0x30, 0xea, 0x31, 0xc7, 0xd5, 0xcb, 0x74, 0xc5, 0x35, 0x0f, 0xa9,
	0xab, 0x0e, 0x0a, 0x18, 0xaa, 0x04, 0x63, 0x5b, 0xde, 0xd7, 0xa2, 0xee, 0xe4, 0x22, 0x9c, 0x5b,
	0xa5, 0xac, 0x4f, 0x8e, 0x64, 0x19, 0x46, 0x43, 0x2f, 0x9f, 0xda, 0x6e, 0x44, 0x64, 0x01, 0x6a,
	0x2d, 0xb4, 0xf1, 0xd9, 0x44, 0x2e, 0xa5, 0x49, 0x16, 0x72, 0x19, 0x40, 0x8a, 0xa0, 0x42, 0xd2,
	0xab, 0x1b, 0x06, 0xf5, 0x3c, 0x11, 0x64, 0x58, 0x0b, 0x97, 0xe4, 0x1a, 0x8c, 0x73, 0xc8, 0x74,
	0xc3, 0x31, 0x74, 0xcb, 0x6a, 0xf4, 0x73, 0xff, 0x04, 0x81, 0x72, 0x87, 0x32, 0xe3, 0xe0, 0x8e,
	0xeb, 0x54, 0x35, 0xfa, 0x41, 0x9d, 0x7a, 0xec, 0x54, 0xef, 0x61, 0x11, 0x06, 0xf6, 0x5d, 0xa7,
	0x2a, 0x6e, 0xe4, 0x64, 0x05, 0x23, 0xce, 0x91, 0xef, 0x10, 0x8c, 0x0b, 0x20, 0x9a, 0x6e, 0x97,
	0xe9, 0x3f, 0x88, 0x84, 0x17, 0x3e, 0x73, 0x44, 0xbd, 0x9c, 0xb0, 0xf0, 0x99, 0x43, 0x1e, 0x03,
	0xac, 0x52, 0x76, 0x16, 0xf4, 0xc1, 0x8b, 0x4e, 0x1c, 0xf3, 0xa2, 0x07, 0xba, 0xbc, 0x68, 0xf2,
	0x25, 0x82, 0x7f, 0x2d, 0x3b, 0xb6, 0x57, 0xaf, 0x52, 0x7e, 0x95, 0xab, 0xae, 0x53, 0xaf, 0x9d,
	0x05, 0xc7, 0x55, 0x18, 0x37, 0xfc, 0x70, 0xae, 0x88, 0xb5, 0xc5, 0x0b, 0x36, 0x21, 0xbc, 0x3a,
	0x37, 0x30, 0x81, 0x91, 0xd0, 0x28, 0x1c, 0x07, 0x84, 0x63, 0xc4, 0x46, 0x7e, 0x44, 0x30, 0x71,
	0x4f, 0xb4, 0xad, 0xe5, 0x83, 0xb3, 0xde, 0x31, 0xe7, 0x44, 0x06, 0x11, 0x20, 0x8b, 0x1a, 0x5f,
	0x05, 0x95, 0xd4, 0x85, 0x07, 0x4f, 0xdb, 0x85, 0xc9, 0x0b, 0x04, 0xea, 0x66, 0xdd, 0x62, 0xe6,
	0xeb, 0x97, 0xde, 0x0a, 0x24, 0x7d, 0x90, 0x9e, 0x3a, 0x38, 0x9b, 0x38, 0x61, 0x7e, 0xe1, 0x51,
	0xde, 0x54, 0xa2, 0xa9, 0x1d, 0xdf, 0x54, 0x76, 0x60, 0x6c, 0x43, 0xf7, 0x98, 0x7f, 0xc4, 0x77,
	0x6e, 0xd1, 0x8c, 0x4e, 0x4d, 0xf3, 0x33, 0x04, 0xe3, 0x72, 0xdc, 0xd7, 0x81, 0xdf, 0x2b, 0xc1,
	0xfc, 0xf2, 0x07, 0xc7, 0x84, 0x34, 0x38, 0x36, 0x75, 0xb7, 0xd2, 0x1a, 0x5f, 0xe4, 0x3d, 0x98,
	0x6c, 0xf6, 0xd9, 0xed, 0x86, 0x6d, 0x9c, 0x05, 0x3e, 0x96, 0x3b, 0x5c, 0xd0, 0x3f, 0x2f, 0x41,
	0x7a, 0x4d, 0xf7, 0x34, 0xea, 0xd5, 0x1c, 0xdb, 0xa3, 0xf8, 0x3c, 0x0c, 0xd1, 0xc7, 0xa6, 0xc7,
	0xc2, 0xbb, 0x09, 0x56, 0x64, 0x17, 0x52, 0x1c, 0xd8, 0x36, 0xd3, 0x59, 0x0b, 0x3c, 0xea, 0x03,
	0x9e, 0xf3, 0x55, 0xa2, 0x16, 0x1f, 0x79, 0x8d, 0x65, 0xa7, 0x6e, 0x33, 0x01, 0x69, 0x50, 0x8b,
	0x1a, 0xc9, 0x4b, 0x04, 0x69, 0x39, 0xb5, 0x05, 0x18, 0x12, 0xd9, 0x70, 0x0c, 0x89, 0x5c, 0xba,
	0x40, 0xe4, 0xb1, 0xda, 0xf2, 0xf3, 0x27, 0xbd, 0x77, 0xdb, 0x66, 0x6e, 0x43, 0x0b, 0x4e, 0x64,
	0x0a, 0xa0, 0x48, 0x2e, 0xc2, 0xa3, 0x6d, 0x44, 0xa2, 0xf6, 0x11, 0x99, 0xd9, 0x83, 0xb4, 0x14,
	0x2a, 0xec, 0xa4, 0x3e, 0xaf, 0xa2, 0x93, 0xbe, 0x15, 0xaa, 0x1e, 0x0e, 0x3f, 0x5d, 0xb8, 0xd2,
	0x03, 0x4f, 0xfb, 0x17, 0x07, 0xf2, 0x68, 0x21, 0xfe, 0x06, 0x22, 0x7f, 0xc6, 0x61, 0xc4, 0xdf,
	0x0f, 0x88, 0x7e, 0xb3, 0x2d, 0xc9, 0xff, 0x76, 0x04, 0xf5, 0x1d, 0xbb, 0x66, 0xf9, 0x2d, 0x82,
	0x71, 0xd9, 0xc9, 0xcf, 0xf3, 0xdd, 0x8e, 0x3c, 0xd3, 0x85, 0x9b, 0xbd, 0xc2, 0x76, 0x1c, 0x9f,
	0x6f, 0xe9, 0x1b, 0xff, 0xcb, 0x64, 0x8a, 0x1e, 0xc0, 0x58, 0xdb, 0x76, 0x17, 0x9a, 0x72, 0x51,
	0x9a, 0xb0, 0x5c, 0x17, 0xbe, 0x62, 0x96, 0x18, 0xc9, 0x94, 0xfa, 0xb1, 0xfe, 0x76, 0x34, 0xdc,
	0xff, 0x5e, 0x39, 0x13, 0xe9, 0x5b, 0xe6, 0x2e, 0x43, 0xaa, 0x29, 0x08, 0xf1, 0x28, 0xa4, 0x1e,
	0x9a, 0x55, 0xea, 0xf2, 0x85, 0x12, 0xc3, 0x00, 0x43, 0xeb, 0x8f, 0xc4, 0x67, 0x34, 0x97, 0x83,
	0xd1, 0x88, 0x62, 0xc3, 0x69, 0x48, 0x6a, 0x8e, 0x51, 0xf1, 0x56, 0x8a, 0xbe, 0x67, 0x51, 0x2f,
	0x95, 0xa9, 0xab, 0xa0, 0xb9, 0xeb, 0xa0, 0xf0, 0x79, 0x69, 0x7a, 0x8c, 0xda, 0x46, 0x63, 0x83,
	0x1e, 0x52, 0x0b, 0x27, 0x21, 0x71, 0x6f, 0xeb, 0xb6, 0xef, 0xf8, 0x60, 0xe7, 0x9e, 0xb6, 0xb3,
	0xa9, 0x00, 0x37, 0xde, 0xda, 0xd8, 0x50, 0x26, 0xe7, 0x76, 0x61, 0x38, 0x7c, 0x17, 0x3c, 0xec,
	0x8e, 0x5d, 0xb1, 0x9d, 0x0f, 0x6d, 0x25, 0x86, 0x47, 0x60, 0x38, 0x18, 0xbd, 0x25, 0x05, 0xf0,
	0x04, 0x8c, 0x6d, 0x39, 0xec, 0x96, 0xc1, 0x77, 0x2d, 0x5a, 0x2a, 0xd3, 0x92, 0x32, 0x89, 0x15,
	0x18, 0x89, 0x58, 0xb2, 0xfe, 0xa1, 0x6a, 0xd5, 0x64, 0xb4, 0xa4, 0xe4, 0x0a, 0xbf, 0xa4, 0x60,
	0xb4, 0xe8, 0x3a, 0x15, 0xea, 0x6e, 0x53, 0xf7, 0xd0, 0x34, 0x28, 0x7e, 0x04, 0x69, 0x49, 0x42,
	0xe3, 0x69, 0x89, 0xb6, 0x0e, 0x69, 0x9d, 0x99, 0x6a, 0x17, 0xce, 0xa2, 0xeb, 0x12, 0xfc, 0xf1,
	0x0f, 0xbf, 0x7f, 0x1e, 0x1f, 0x21, 0xc9, 0xbc, 0x5f, 0x70, 0x0b, 0x68, 0x0e, 0x6f, 0xc2, 0xd4,
	0xfd, 0xfa, 0x9e, 0x65, 0x7a, 0x07, 0xc1, 0x65, 0x7a, 0xdb, 0xcc, 0xa5, 0x7a, 0x15, 0x77, 0xb9,
	0xe7, 0xcc, 0x74, 0x9b, 0x12, 0x8e, 0xc8, 0x4a, 0x12, 0xcb, 0x21, 0xfc, 0x0e, 0x0c, 0x87, 0xe2,
	0x16, 0xff, 0x5b, 0xf2, 0x8e, 0xea, 0xe2, 0x8c, 0xda, 0x65, 0xcb, 0x0f, 0x72, 0x5e, 0x60, 0x54,
	0xf0, 0xb9, 0x00, 0x63, 0xfe, 0x09, 0xd7, 0xc3, 0x4f, 0xb1, 0x0d, 0xc9, 0x00, 0x67, 0x57, 0x64,
	0xf2, 0xbf, 0x0a, 0xcd, 0x7f, 0x5a, 0xc8, 0x4d, 0x11, 0xec, 0x06, 0x19, 0x6b, 0x06, 0x13, 0x7f,
	0x9f, 0x2e, 0xa0, 0xb9, 0xdd, 0xff, 0x90, 0x0b, 0x6d, 0xd6, 0xfc, 0x93, 0xe6, 0xd3, 0x78, 0x8a,
	0x97, 0x20, 0xd5, 0x6c, 0xd0, 0xf8, 0x82, 0x14, 0xbd, 0x5d, 0x1e, 0x67, 0xba, 0xc0, 0x21, 0xb1,
	0xeb, 0x08, 0x17, 0x01, 0x5a, 0x0a, 0x36, 0x72, 0x61, 0x1d, 0xc2, 0xb6, 0x67, 0x8c, 0x75, 0x98,
	0x10, 0x3c, 0xff, 0x2d, 0x77, 0xf3, 0x35, 0xf2, 0x6b, 0x5c, 0xd6, 0x84, 0x58, 0xee, 0xc2, 0x3d,
	0x04, 0x63, 0x57, 0x74, 0x54, 0x50, 0xfb, 0x3e, 0x3e, 0x8e, 0xc4, 0xdd, 0x25, 0xbc, 0x78, 0xcc,
	0x76, 0xfe, 0x49, 0x87, 0x72, 0x94, 0x6c, 0x62, 0x79, 0x1d, 0xe1, 0x6f, 0x10, 0xa4, 0xa5, 0xb7,
	0x82, 0xb3, 0x12, 0x98, 0x2e, 0x02, 0x2b, 0xc2, 0x43, 0x87, 0x4a, 0x21, 0x96, 0x80, 0xbd, 0x4f,
	0x66, 0x42, 0x5c, 0xba, 0x51, 0xe9, 0x86, 0x8d, 0x57, 0xc8, 0x12, 0x59, 0xec, 0xe3, 0xd5, 0x96,
	0x41, 0x3b, 0x7a, 0xbc, 0x0b, 0x13, 0x12, 0xf4, 0xf0, 0x12, 0xb1, 0x3c, 0x14, 0x7a, 0x09, 0xc5,
	0x3e, 0x79, 0xc4, 0xf0, 0x33, 0x04, 0x43, 0x7e, 0xc7, 0x38, 0x23, 0x25, 0xae, 0xa0, 0xc4, 0x22,
	0x24, 0x4c, 0xd6, 0x10, 0x51, 0x7b, 0xb1, 0xb2, 0x4c, 0x6e, 0xf5, 0x77, 0xec, 0x43, 0x4c, 0xe1,
	0xd3, 0x01, 0x18, 0xbb, 0x6b, 0x33, 0xea, 0xda, 0xba, 0x15, 0x76, 0x38, 0x2d, 0x5a, 0xeb, 0x41,
	0xf9, 0x9e, 0xa2, 0xd6, 0x53, 0x22, 0xa1, 0x04, 0xef, 0x6e, 0xff, 0x17, 0xed, 0xa8, 0xd8, 0x58,
	0xa7, 0x0d, 0x3c, 0x15, 0xed, 0x39, 0xc7, 0x3e, 0x3d, 0x7c, 0x13, 0x86, 0xd6, 0x74, 0xef, 0x98,
	0x63, 0xe7, 0x25, 0xb3, 0xa4, 0xb4, 0x48, 0x0c, 0xaf, 0xc1, 0x68, 0x44, 0xda, 0xe1, 0x99, 0x6e,
	0xdd, 0x43, 0x52, 0x15, 0x3d, 0x5f, 0xff, 0x1a, 0x40, 0x4b, 0xe0, 0x46, 0x3a, 0x48, 0x87, 0xee,
	0xcd, 0x64, 0x7a, 0xec, 0xfa, 0xc5, 0xb2, 0x05, 0x23, 0x7c, 0x56, 0x85, 0x63, 0xe9, 0x8c, 0x15,
	0x13, 0xe3, 0x7d, 0x69, 0x95, 0xb2, 0xa6, 0x74, 0x0c, 0x7f, 0x39, 0xeb, 0x17, 0xb6, 0x6b, 0xa2,
	0xc5, 0x4b, 0x3f, 0xbd, 0xcc, 0xc6, 0x3e, 0x3a, 0xca, 0xa2, 0xaf, 0x8e, 0xb2, 0xe8, 0xf9, 0x51,
	0x16, 0x7d, 0x7f, 0x94, 0x45, 0xbf, 0x1e, 0x65, 0xd1, 0x17, 0xbf, 0x65, 0x63, 0xbb, 0x49, 0xaf,
	0xec, 0xff, 0x74, 0x37, 0x24, 0xfe, 0xdc, 0xf8, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x47, 0xaa, 0x6c,
	0x41, 0x14, 0x14, 0x00, 0x00,
}
